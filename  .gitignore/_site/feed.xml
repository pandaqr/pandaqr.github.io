<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>坚果</title>
    <description>Roon was an excellent service, with a beautiful understated design. Roon was eventually acquired by Ghost, who awesomely chose to open source the theme. &lt;br/&gt;This is my Jekyll port of the Roon theme
</description>
    <link>http://pandaqr.github.io/</link>
    <atom:link href="http://pandaqr.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 13 Jan 2016 20:08:56 +0800</pubDate>
    <lastBuildDate>Wed, 13 Jan 2016 20:08:56 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>The Guide to Wireframing</title>
        <description>&lt;p&gt;Wireframing主要目的是为了将概念转化为可见的内容给到别人。 
交互设计师，视觉设计师，工程师，产品经理以及公司和合作伙伴都需要用到线框图。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;线框图的作用&lt;/h2&gt;
&lt;p&gt;线框图的作用是为了让所有的参与开发的人员在同一个频道上，传递即使的信息。
其主要传递以下的信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;结构—网站的结构是如何的，如何将不同的元素组合起来&lt;/li&gt;
  &lt;li&gt;内容—什么内容会在网站上显示&lt;/li&gt;
  &lt;li&gt;信息架构— 信息是如何组织是如何展示的&lt;/li&gt;
  &lt;li&gt;功能— 界面是如果运作的&lt;/li&gt;
  &lt;li&gt;行为—网站是如何同用户交互的，其表现如何&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;画线框图的工具&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;直接在纸上画草稿&lt;/li&gt;
  &lt;li&gt;纸张模型&lt;/li&gt;
  &lt;li&gt;线框图软件&lt;/li&gt;
  &lt;li&gt;视觉软件&lt;/li&gt;
  &lt;li&gt;PPT/ Keynote&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此总体来说画线框图的工具主要分两类，电子类，以及非。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;非电子产品类工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在纸上起草（sketching）&lt;/li&gt;
  &lt;li&gt;在白板上&lt;/li&gt;
  &lt;li&gt;剪纸&lt;/li&gt;
  &lt;li&gt;模型
使用非电子类产品的好处很明显，速度是其核心优势，对于画线框图其实就是需要将点子转化为实物输出出来。 
而在纸上或者在白板上直接画是一种最直接最方便，最灵活，并且成本最低的方式。 当然缺点也显而易见，比如，改动不方便，低保真，不能呈现交互结果，版本迭代控制问题，不支持协同合作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那如果使用剪纸或者固有的模型素材去做呢？ 这似乎是一种挺有趣的方式，因为你可以自由调配纸张，从而模拟交互。 当然，自己剪纸的话，肯定话费的时间成本也就上去了，而直接使用固有的素材模型，会导致创造收到一定的局限性。&lt;/p&gt;

&lt;p&gt;私以为，可以先在纸上画线框图，然后可以将部分的界面用剪纸的形式做纸上的交互模拟，会是一种很有趣的实现方式。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;电子类工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;写作类工具（ word,pages,Google Docs,etc)&lt;/li&gt;
  &lt;li&gt;视觉设计软件（Photoshop,Sektch)&lt;/li&gt;
  &lt;li&gt;Presentation software(ppt,Keynote)&lt;/li&gt;
  &lt;li&gt;专业的线框图设计软件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先来说word这种，优势很明显，就是够熟悉，但是个人认为，很多人除了会用word打字之外，插入一个表格可能都有问题，因此word先天的固有设定是其最大的弱点。&lt;/p&gt;

&lt;p&gt;而相对来说可能在我们印象中比较多的会用来处理图形的软件就是ppt了，但其也没有什么画线框图的素材，要去网上找或者自己画。
有趣的是有一个网站叫做&lt;a href=&quot;http://keynotopia.com&quot;&gt;keynotopia&lt;/a&gt;,这个网站的标语就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Use Tools You Know to Prototype Like a Pro。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是似乎里面给到的素材都是ios6时期的，而且如果要下需要付费。 因此这种固有的元素最大的问题就是素材的更新与设定问题，很大的程度上限制了灵活性。&lt;/p&gt;

&lt;p&gt;再来看看视觉设计软件，这个对于设计师来说真是再熟悉不过，但是通常我们用视觉软件都是做最后的UI设计，弄不好弄着弄着就会去追求字体和颜色搭配了。当然Sketch还提供Ios设计的界面模板，可以很方便的拿来用，但是要开两个文件总觉得好麻烦。&lt;/p&gt;

&lt;p&gt;这一点使用专业的线框图设计软件就能得到叫好的解决，因为其素材库的强大优势，能让我们不用操心太多直接拿来用。 也可以做画流程图，实现一定的交互。 速度上也较快，并能很快的输出PDF用作presentation.&lt;/p&gt;

&lt;p&gt;当然工具只是工具啦~ ，用着顺手就行。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;高保真低保真&lt;/h2&gt;
&lt;p&gt;画线框图也讲究高保真滴保真，但是很多元素并不需要考虑进去，比如说颜色字体之类的，因为这些到后面会有更加专业的视觉设计师来决定，不需要纠结于此，反正之后还是很可能会被替代&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;线框图标注&lt;/h2&gt;
&lt;p&gt;画线框图一定要做标注&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;功能性： 哪里是需要点击，滑动，缩小，放大，弹出。。&lt;/li&gt;
  &lt;li&gt;内容： 字体，布局，大小，连接，图片，媒体，分辨率&lt;/li&gt;
  &lt;li&gt;行为： 动画效果，速度，位置，交互，连接。&lt;/li&gt;
  &lt;li&gt;其他限制： 软件硬件，浏览器，数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;线框图网站&lt;/h2&gt;
&lt;p&gt;Guide 里还介绍了一些线框图的网站，可能比较多，有些都已经不更新了。主要先就记录一下这几个网站吧~&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.wireframeshowcase.com&quot;&gt;wireframeshowcase&lt;/a&gt;
可以看到线框图和完成后网站的一个对比以及设计流程。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;uxarchive.com&quot;&gt;Ux Archive&lt;/a&gt;
顾名思义，主要是为了提升用户体验的网站，里面有各种各样的UI界面，但是没有线框图。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://pttrns.com&quot;&gt;pttrns&lt;/a&gt;
将UI设计的元素分门别类，比如你要设计卡片类型的，就能为你找到一堆卡片类型的设计界面。但是基本都是UI界面，无线框图。&lt;/p&gt;

&lt;h2 id=&quot;ui-design-pattern&quot;&gt;UI Design Pattern&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Good artists borrow, great artists steal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这毕加索的名言也被乔布斯极力的推崇，但是我们需要清晰的意识到，这里面提高的Steal的意义。 将遇到的好的作品，看到的好的设计内核化，转化并吸收为自我的内容，转而创新以及重新设计。而不是说就偷懒去抄袭了。&lt;/p&gt;

&lt;p&gt;那接下去我们来谈谈关于界面设计交互等得一些模式&lt;/p&gt;

&lt;p&gt;文章里提到的一些app例子很多大陆基本都不怎么用，我试着找找有什么相似的在大陆也能找的app上适用的予以举例说明。&lt;/p&gt;

&lt;h3 id=&quot;visibal-scrollbar&quot;&gt;可视化滚动条(Visibal Scrollbar)&lt;/h3&gt;
&lt;p&gt;这里的滚动条和我们平时网页上看文章出现的滚动条不大一样。 
&lt;img src=&quot;img/wireframe/屏幕快照 2016-01-09 下午3.07.47.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里的滚动可以帮助你分类，Carousel是一个照片分享网站，可以通过截图看到它将你的照片按时间自动分门别类了，能较快的搜索到你所需的文件。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;卡片&lt;/h3&gt;
&lt;p&gt;Pinterest 引进了卡片这一概念，卡片的这一浏览方式，让人们更加沉浸的发现好内容，同时可以将其分类以及做一些交互。
&lt;img src=&quot;img/wireframe/1.pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;地图背景&lt;/h3&gt;
&lt;p&gt;这一个模式已经在App上得到了广泛的应用，也可以看到这带动了已照片或者媒体作为背景的模式。
&lt;a href=&quot;http://www.wandoujia.com/eyepetizer/&quot;&gt;开眼&lt;/a&gt; 算是一个不错的例子
&lt;img src=&quot;img/wireframe/2.pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;thumbnails-in-circles&quot;&gt;圆形用户头像缩略图（thumbnails in circles）&lt;/h3&gt;
&lt;p&gt;Facebook和Instagram采用了这种用户缩略头像为圆形的方式，在Google+这边得到了进一步的推广，Path的出现也更加推动了让这种圆形头像得使用。
我们在QQ上可以看到其使用。&lt;/p&gt;

&lt;h3 id=&quot;transforming-the--into-an-x-button&quot;&gt;按钮动效（transforming the “+” into an “x” button）&lt;/h3&gt;
&lt;p&gt;可以在Pinterest上看到其“+”会在按下去的时候转化成”x”.这种按钮的动画效果也可以在&lt;a href=&quot;http://www.qdaily.com&quot;&gt;好奇心日报&lt;/a&gt;菜单拉出及退出上看到。&lt;/p&gt;

&lt;p&gt;这样做的好处是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将区别不大的按钮自然转化，&lt;/li&gt;
  &lt;li&gt;视觉上将元素之间完美的联系起来&lt;/li&gt;
  &lt;li&gt;给到用户一定的视觉反馈，知道发生了什么
&lt;img src=&quot;img/wireframe/屏幕快照 2016-01-09 下午10.43.35.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这张截图是Pinterest的旧界面。&lt;/p&gt;

&lt;h3 id=&quot;manipulate-content-directly&quot;&gt;自由操控调动内容（manipulate content directly）&lt;/h3&gt;
&lt;p&gt;Asana 是一个类GTD的时间管理应用， 你可以将安排好的条目用按压的方式自动的拖动仿制条目的位置。 
&lt;img src=&quot;img/wireframe/屏幕快照 2016-01-09 下午10.47.48.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于有许多栏目需要操作貂整其位置的时候，这种交互方式是一个非常好的解决方式。&lt;/p&gt;

&lt;h3 id=&quot;swiping-actions&quot;&gt;左右滑动（swiping actions）&lt;/h3&gt;
&lt;p&gt;这种交互我们见的已经相当多了，在iPhone自带的email 应用里就可以动作左右滑动删除或标注已阅。 
&lt;img src=&quot;img/wireframe/3.pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;discover-faster-actions&quot;&gt;隐藏按钮（discover faster actions）&lt;/h3&gt;
&lt;p&gt;这种按钮可能需要用户自己去探索发现，Instagram就有这个一个双击图片表示喜欢的功能，这个好处当然是操作更加的快捷，但是也造成让人误点的情况，而要去删除这个喜欢需要去其他界面操作。&lt;/p&gt;

&lt;h3 id=&quot;discoverable-tools&quot;&gt;隐藏工具（“discoverable” tools）&lt;/h3&gt;
&lt;p&gt;这个在Snapseed上有着完美的体现。 修图通常需要用到许多的工具，但是一一罗列出来可能是一件相当麻烦的事情，这时候通过左右或上下移动手指就能导出工具栏，用起来相当的方便。 
&lt;img src=&quot;img/wireframe/4.pic.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;invite-others&quot;&gt;邀请朋友(invite others)&lt;/h3&gt;
&lt;p&gt;邀请朋友通常就两种方式，通过邮件和通讯录，将通讯录以及邮件联系人列出来这大大方便了分享的速度。
可以简单看一下Venmo的截图， 当然也可以去体验一下path的邀请方式，同样简单方便。 
&lt;img src=&quot;img/wireframe/屏幕快照 2016-01-09 下午11.15.06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;线框图设计原则&lt;/h2&gt;
&lt;p&gt;非常重要的一点就是要时刻记住你是在为谁设计，你的用户是哪些人。 
用户是最重要，要摸清用户的需求再慢慢展开，不要自己一个人瞎猜。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;功能&lt;/h3&gt;
&lt;p&gt;你的产品不是一对功能的叠加，最最重要的是要知道你产品的核心任务。在思考功能的时候需要考虑以下几个问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果你的产品要运作良好，你需要什么？&lt;/li&gt;
  &lt;li&gt;除了核心功能，你能去除多少个其他的功能？&lt;/li&gt;
  &lt;li&gt;为什么人们会喜欢你的产品&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;简单化&lt;/h3&gt;
&lt;p&gt;将你的产品简单化，这样做的好处是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果你做的尽量简单化，那么你就有更多的时间考量，去测试其使用体验&lt;/li&gt;
  &lt;li&gt;一款新的App对于用户来说始终是陌生的，他们需要花时间去探索去学习，降低学习成本这将帮助你提高用户留存率&lt;/li&gt;
  &lt;li&gt;产品花销也就小了，帮助你更好的专注在优秀额资源上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;改变不是提高&lt;/h3&gt;
&lt;p&gt;不要觉得你给App做出一些改变，用户就会觉得这是一次提高了，其实人是很难接受变化的，如果没有质的提升不如不改&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;保持一致&lt;/h3&gt;
&lt;p&gt;在做线框图的时候，不要用什么五颜六色，保持连贯性与一致性能更好的向别人传递你的想法。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;低保真不代表不切实际&lt;/h3&gt;

&lt;h3 id=&quot;section-15&quot;&gt;不要等到产品完整了再发布&lt;/h3&gt;
&lt;p&gt;如果你已经在纸上画了原型图也也觉得够好了就直接给别人去看，没什么大必要再用其他工具去画一遍，直接拍照给到别人分享。&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Jan 2016 20:12:12 +0800</pubDate>
        <link>http://pandaqr.github.io/2016/01/10/the-guide-to-wireframing.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2016/01/10/the-guide-to-wireframing.html</guid>
        
        
      </item>
    
      <item>
        <title>The Guide to Mockups</title>
        <description>&lt;p&gt;最近在看Uxpin上的一系列电子书，犹如发现宝库一般，一堆一堆的。
那就先从最基本的Mockup，Wireframe以及prototype开始吧&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://studio.uxpin.com/ebooks/guide-to-mockups/&quot;&gt;&lt;strong&gt;The Guide to Mockups&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基本就是介绍了Mockup，wireframe ,prototype 之间的区别与概念。&lt;/p&gt;

&lt;p&gt;Wireframe是Skeleton骨架，而Mockup就是Skin&lt;/p&gt;

&lt;p&gt;因此这三者之间的进展顺序应该是 wireframe&amp;gt;mockup&amp;gt;prototype&lt;/p&gt;

&lt;p&gt;通常mockup 的方式可以在纸上直接进行，可能比较耗时，但可以以激起设计师的灵感。&lt;/p&gt;

&lt;p&gt;也可以在电脑上做Mockup,工具可以用PS和Sketch，但这就是高保真Mock up了。还有一种叫做中保真Mock ups.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;高保真的好处&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;接近最终成品&lt;/li&gt;
  &lt;li&gt;让客户提前看到完成品的样式&lt;/li&gt;
  &lt;li&gt;提前决定字体，颜色，幕布等，不用等到最后prototype再决定&lt;/li&gt;
  &lt;li&gt;如又要修改的会比较方便，而不是等到prototype出来了再去改什么代码，成本太高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mockups&quot;&gt;为何不支持Mockups&lt;/h2&gt;
&lt;p&gt;当然也有人反对Mockup，认为其设计的花里胡哨最终可能无法良好的转化为代码。因此提倡直接在代码上画。&lt;/p&gt;

&lt;p&gt;但问题是:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码限制了想象力&lt;/li&gt;
  &lt;li&gt;无法实验多种效果&lt;/li&gt;
  &lt;li&gt;修改成本高&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mockups-1&quot;&gt;Mockups的作用&lt;/h2&gt;

&lt;p&gt;其实Mock up就是设计同程序之间的一个衔接，在设计的时候要注意的细节有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;命名，同程序员商量命名方式能直接在Xcode上直接使用&lt;/li&gt;
  &lt;li&gt;和程序员商量设计方案的可信性，不要变成飞机稿&lt;/li&gt;
  &lt;li&gt;给不同平台设计的时候一定要遵循其平台特征&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在做Mock up的时候也一定要添加Notes，其也能通过颜色的变化显示某种交互的 方式，比如按钮按下去就从白色变成了红色。&lt;/p&gt;

&lt;p&gt;及早的同客户沟通，打成共识，将设计的主导权掌握在自己的手上。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;访问者浏览习惯&lt;/h2&gt;

&lt;p&gt;关于网页设计布局需要了解访问者的浏览习惯，我们可以回想一下自己浏览网站的习惯，通常我们是不会去认认真真的看文章的每一个字的，我们用的方式基本都是扫视。&lt;/p&gt;

&lt;p&gt;调查实验也发现人们有两种浏览网页的方式，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nngroup.com/articles/f-shaped-pattern-reading-web-content/&quot;&gt;F-Pattern&lt;/a&gt; (for text-heavy content)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://webdesign.tutsplus.com/articles/understanding-the-z-layout-in-web-design--webdesign-28&quot;&gt;Z-Pattern&lt;/a&gt; (for general content).&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 02 Jan 2016 20:12:12 +0800</pubDate>
        <link>http://pandaqr.github.io/2016/01/02/the-guide-to-mockups.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2016/01/02/the-guide-to-mockups.html</guid>
        
        
      </item>
    
      <item>
        <title>项目小结</title>
        <description>&lt;p&gt;上次说到最近做的一个项目，在这里简单的梳理一下。 
我是半当中插进去的，因为之前美工的离开，因此项目一开始的建立我并非十分清楚，而且前设计跑掉的时候她已经将所有的界面全部设计完成了，可是她切的图工程师都不能用，因此留给我的工作只有两大块：1.设计启动页面 2. 切图及标注。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当拿到设计原稿的时候，我内心是崩溃的，因为这位设计师的布局相当的混乱，图层都没有按照规定去命名和编组，因此在选择需要的元素的时候，相当的不方便。这里很重要的一点是，你不知道你的设计会给到谁继续沿用，因此，良好的命名习惯以及分组习惯将会为不管是他人还是自己带来极大的方便。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;前设计用了iPhone5s的两倍图来设计，这个设计尺寸给标图造成了一定的问题，因为在标图的时候是直接用了px，工程师到时候还要自己除以2变成pt，这样就会产生小数点。在最后的切图工作中也会造成极大的不便。当然我后来得知是由于工程师自己用iPhone5s所以让设计用iPhone5s来设计了，但是这个时候设计师就应该坚持自己的立场，把原理以及原因一条条的告诉到工程师，为何用iPhone6的尺寸来设计是最合适的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目的建立之初，客户会阐明自己的需求，因此你收到的需求文档很可能是一篇粘合在一起没有空行的文章，这个时候需要自己一个个将其剖析，分析，拆开，动手画逻辑图，理清功能界面需求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;原型图是一枚ios工程师自己画的，也算是新上手，这让我有点不思其解，明显这应该是UI/UX自己来做的事情，怎么就变成工程师的任务了，但是工程师相对来说思路清晰，逻辑明确，其实这也就是将客户的需求用图解的方式表达出来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;前设计做的那些界面图，说实话和原型图真长得差不多，这会给工程师带来一个困惑：那我尼玛还需要设计师干嘛？ 这里有一个问题，就是交互设计师其实已经很大一部分将界面都布局好了，而这时候视觉工程师需要做什么？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分析竞品的设计&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确定用哪个分辨率来设计&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据产品的气质决定产品的主色调，以及界面质感（是拟物还是扁平）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更具不同平台的特点设计（iOS上面能实现的动画，Andriod上实现起来不一定容易，可能会导致系统卡克，这时候导致用户体验下降的设计就需要为Andriod重新设计，再比如Windows Phone上是扁平直角的风格，若用拟物风格将会格格不入）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字体的选择与使用（ 标题放大到什么程度？ 用什么字体能同产品的气质想吻合）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;把控UE。由于UE在设计的时候并非是完成品，只是排布了控件的大致位置，而UI在最终设计的时候呈现出来的是充实的具体的效果，因此在更加的饱满的界面上更能够感知到如何布局才能使得交互更加完善。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图标。图标的风格也在很大程度上左右着一款产品的气质，寻找设计同产品风格相一致的图标也是至关重要的，而在iOS上自带了共识的图标，在应用中重复使用也是提高用户体验，降低用户学习成本的很好的一种方法。同时在使用图标的时候也需要思考这个地方是直接放图标比较好，还是配以文字说明会更加容易让人理解。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Logo的设计&lt;/li&gt;
  &lt;li&gt;UI动画&lt;/li&gt;
  &lt;li&gt;切图&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;在做欢迎页面设计的一开始，我的灵感是枯竭的，这时候就提醒了我们需要不断的去采集，多看多思考其他的欢迎界面。我拿到得这个项目欢迎页的文案是客户规定的，客户有自己的想法，他希望设计的风格也有提出，比如不希望用手机截面图来做说明，希望用图标，而在两者之间并没有哪个特别好的情况下，按照客户的要求去做也是可以的。&lt;/li&gt;
  &lt;li&gt;欢迎页面一个四页，做的时候要清晰明确地内容有：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1） 产品的主要功能是什么，关键字是什么
2） 欢迎页的风格是单线条风格？，单色风格？ 彩色风格？拟物？真人？真实照片？ 还是需要添加一定的动效？
3） 文案是否短小精炼，可否标注关键字，图片是否有同文案传递的信息紧密吻合？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;切图的时候命名很重要，应当全部使用英文，命名规则可以同工程师先说好，或者就使用统一的命名规则驼峰式，or下划线分割式&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;空白&lt;/strong&gt;
迷迷糊糊的学完Photoshop之后，还有一堆需要补习的，这些工具要学起来说快不快，说慢也不慢，Sketch上手速度绝对是杠杠的，但是这背后的问题是，越容易上手，越容易被替代，不容易被替代的是设计的背后的思维。&lt;/p&gt;

&lt;p&gt;这周把搜狐的《设计之下》给看完，今早解决了原研哉的《白》，一本是直接与UI设计对接的UI工作笔记，一本则是上升到某一个高度去思考白的属性。设计的思维固然重要，设计工作中得沟通，设计师自身的表达说服能力似乎也是尤为重要的，不是凭感觉去设计，而是为了一个目标，为了解决问题，为了让产品成为与用户良好沟通的桥梁而设计。&lt;/p&gt;

&lt;p&gt;拿到新iPhone6s的时候，我想的是得赶快打开用起来，但尼玛要插sim卡激活？？？没小卡啊？激活了问我要不要备份？ 开玩笑，icloud这么高端的东西，从来用不来，虽然知道这是“云”，但为何，百度云就用的很溜，iCloud加了一个i就懵了。。。于是，备份什么备份，直接当新的来，这样的好处是，它是一个干净的，纯净的iPhone，而不是一个继承了我过往习惯的iPhone。可能我没太多联系人，没太多重要的照片，要备份的，百度云也弄好了，于是用了最原始的方式，一个个的去输入联系人，一个个的去下载应用，这样的好处在我看来其实很大：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个手机用了两三年，联系人里面总有许多永远不联系的人，于是细细数下来除了家人，真正的朋友和工作同事就没两个人了&lt;/li&gt;
  &lt;li&gt;应用，其实有很多费的，根本一年也打不开一次的。那就算了吧，不用全部下下来了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该删的删，藏着也是占容量。 
在空白的地方填充只是需要的东西，这就够了。&lt;/p&gt;

&lt;p&gt;Over.
&lt;strong&gt;**&lt;/strong&gt;*
近日在翻译一本电子邮件书:Fundamental UI Design 书中没多大的涉及工具，但有很好的阐述UI设计的方方面面，从定义，到设计原则，再到市场和销售以及沟通，都有一定的启发性，择日慢慢放上来。 
感兴趣的可以先将英语原版订阅起来&lt;a href=&quot;http://www.invisionapp.com/ecourses/fundamental-ui-design?ref=heydesigner&quot;&gt;Fundamental UI Design &lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Dec 2015 15:44:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/12/06/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/12/06/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93.html</guid>
        
        
      </item>
    
      <item>
        <title>自建PIWIK-ALL WEBSITES DASHBOARD页面</title>
        <description>&lt;p&gt;Piwik是一款开源流量监测工具，好用好看好配置，好处自然不用多说。但也有一些小问题，私以为Piwik的可配置参数项还不够多。&lt;/p&gt;

&lt;p&gt;前段时间一直在纠结如何在「所有网站」这个页面上加上「访客数」这个指标，一通翻找Piwik源码，发现水有点深，另外考虑到以后的升级，所以在想如果我把它的源码给改了，那以后方便的一键升级是不是玩不转了，或者说升级之后又需要重新再修改一遍，经过重重考虑，决定还是绕道，既然Piwik这么强大，提供的API如此丰富，何不如再写一个自己的「所有网站」页面，展示自己认为比较重要的检测指标，这种灵活性是不是爆棚，所有就自己写了一个「所有网站」的Dashboard页面。&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;项目源码下载到本地之后，如果需要跑起来，还需要修改这么几个地方：&lt;/p&gt;
&lt;p&gt;1、~/js/piwik-tongji.js中的&lt;code&gt;http://www.yourpiwikserver.com&lt;/code&gt;替换成你自己Piwik的服务器地址，token_auth请替换成你自己Piwik的授权码；&lt;/p&gt;
&lt;p&gt;2、如果想要在本地进行测试，并且你的Piwik并没有安装在本地，那么还涉及到一个跨域的问题，可以在Chrome的浏览器里面装一个插件&lt;code&gt;Allow-Control-Allow-Origin: *&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;Need to be done&lt;/h3&gt;
&lt;p&gt;1、还是有很多值得优化的地方，比如页面布局&lt;/p&gt;

&lt;h3&gt;At Last&lt;/h3&gt;
&lt;p&gt;最后上一张效果图(好像有点以假乱真)：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/11/piwik.png&quot; alt=&quot;DASHBOARD页面&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/11/19/piwik-all-websites.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/11/19/piwik-all-websites.html</guid>
        
        
      </item>
    
      <item>
        <title>深入理解JVM—类加载的时机</title>
        <description>&lt;p&gt;最近在读《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书，对于深入理解JVM的基础技术概念大有帮助，现对「类加载时机」这块逻辑处理过程进行一个简单的回顾和总结。&lt;/p&gt;

&lt;p&gt;众所周知，JVM在字节码上运行，字节码从何而来，从高级源码编译过来，当年在制定Java虚拟机规范时并没有强制规定JVM只能运行由Java源代码编译过来的字节码，不管何种高级开发语言，只要编译后的字节码符合JVM的规范，理论上都能在JVM上运行，好了，扯远了。Java程序从加载到虚拟机内存中开始，到从内存中移出大致需要经历以下过程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;img src=&quot;/assets/images/2015/11/jvm-class-load-time.png&quot; alt=&quot;类加载的时机&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们从逻辑上把Java程序执行的完整链条切割成各个阶段，后一阶段的顺利执行取决于上一阶段的执行结果，前后依赖。下面对各个阶段所执行的操作作一简单介绍：&lt;/p&gt;

&lt;p&gt;
加载：我们在这里说的加载指的是类的加载，大致需要完成以下几件事情：
1）根据类的全路径名称获取描述此类的二进制字节流。这个动作一般通过「类加载器」来实现，「类加载器」是一块在Java虚拟机外部实现的动作代码，从Java虚拟机的角度出发，存在两种不同的类加载器：启动类加载器（由C++实现，是JVM的一部分）和其他类加载器，启动类加载器负责把&lt;java_home&gt;\lib目录中的类库加载到虚拟机内存中；其他类加载器中的扩展类加载器负责加载&lt;java_home&gt;\lib\ext目录中的类库；应用程序类加载器则负载加载用户类路径上指定的类库。
2）将这个字节流所代表的静态存储结构（比如类变量）转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的Java对象，通过该对象来访问该类的各种数据。


&lt;p&gt;
验证：确保上一步加载进虚拟机的字节流不包含危害虚拟机自身安全的信息，主要进行以下几个验证操作：
1）文件格式验证：验证字节流是否符合Class文件格式的规范；文件格式验证基于二进制字节流进行，通过该验证之后，字节流才会进入内存的方法区中进行存储，所以后面的验证操作都基于方法区中的存储结构进行，不会再直接操作字节流；
2）元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息；
3）字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
4）符号引用验证：对类自身以外的信息进行匹配性校验，比如通过字符串描述的全路径名称是否能找到对应的类。
&lt;/p&gt;

&lt;p&gt;
准备：为类变量在方法区中分配内存空间，并设置初始值，需要注意几个关键的地方：
1）仅仅只为类变量（类中以static修饰的变量）分配内存空间，并设置初始值；
2）准备阶段为变量设置初始值一般指的是变量对应类型的零值，比如public static int xyz = 123，准备阶段过后变量xyz的初始值为零，123赋值给xyz的操作需要等到初始化阶段才真正执行，但是也有一个例外情况：如果变量xyz具有ConstantValue常量属性，public static final int xyz = 123，那么xyz在准备阶段就会被初始化成值123。各变量对应的零值如下图所示：
&lt;/p&gt;

&lt;p&gt;解析：主要完成把常量池内的符号引用替换为直接引用&lt;/p&gt;

&lt;p&gt;
初始化：真正开始执行类中定义的Java程序代码（其实是字节码）
初始化阶段主要执行类构造器&lt;clinit&gt;()方法，&lt;clinit&gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，另外需要注意以下几个比较重要的地方：
1）&lt;clinit&gt;()方法与类的构造函数不同，前者不需要显式的调用父类的&lt;clinit&gt;()方法，Java虚拟机保证会在调用子类的&lt;clinit&gt;()方法之前先执行父类的&lt;clinit&gt;()方法，也就意味着父类中定义的静态语句块先于子类的变量赋值操作。


&lt;p&gt;解析这一阶段所需要完成的工作相对来说是比较复杂的，可以另外再进行说明。&lt;/p&gt;
&lt;/clinit&gt;&lt;/clinit&gt;&lt;/clinit&gt;&lt;/clinit&gt;&lt;/clinit&gt;&lt;/clinit&gt;&lt;/p&gt;&lt;/java_home&gt;&lt;/java_home&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/11/11/jvm-class-load-time.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/11/11/jvm-class-load-time.html</guid>
        
        
      </item>
    
      <item>
        <title>重要的五分钟(GIVE IT FIVE MINUTES)</title>
        <description>&lt;h3&gt;Something Go First&lt;/h3&gt;

&lt;p&gt;这是一篇译文，来自Jason Fried的《Give it five minutes》，读完对自己触动很大，曾经或者当下的自己都像极了年轻时候的Jason Fried，当然没有他如此大的成就，这篇文章中的观点值得自己借鉴：「先学会聆听，思考，再据理力争」，做一个会思考深刻的人。&lt;/p&gt;

&lt;h3&gt;译文正文&lt;/h3&gt;

&lt;p&gt;几年前，我还是一个行事莽撞的人。无论别人说了什么，我都认为他说的不对。如果某件事不符合我的世界观，我则会狠狠的反击。&lt;/p&gt;

&lt;p&gt;这就比如说我才是第一个应该提出某种观点的人，似乎成为意见领袖对我来说是一件非常重要的事情。然而事实是我对问题缺乏深度的思考，你反驳的越快，说明你思考的越少，虽然并不总是这样，但几乎是。&lt;/p&gt;

&lt;p&gt;谈起膝跳反射时很轻松随意，好像这只是别人才会有的反应，你也有。如果你的邻居没有免疫能力，那么你也没有。&lt;/p&gt;

&lt;p&gt;时间退回到2007年，当时我正在Providence, RI举办的商业创新工厂会议(Business Innovation Factory conference)上发言，Richard Saul Wurman也安排了发言。在我的演讲过后，他上来向我介绍他自己，同时赞扬了我的发言，他是如此大方，显然他不需要这么做。&lt;/p&gt;

&lt;p&gt;但是你知道我接下来都做了些什么吗！？我对他的方言进行了狠狠的反驳。当时他在台上发言表述他的观点，而我在创新方面上和他意见相佐。等到会议间隙我有机会跟他对话时，我对他的某些观点进行了急不可耐的反驳。当时我的样子看起来像极了傻瓜。&lt;/p&gt;

&lt;p&gt;然而他的回应改变了我的一生。『这简单』他说，『伙计，先思考五分钟』，我问这是什么意思？他说：『不同意我的观点没关系，对我的观点进行反驳也无所谓，并且坚守自己的观点和信念是一件好事，但是在你确认反驳我的观点之前能否给我的观点留点时间，先思考一下』。原来他说的「五分钟」代表「思考」，而不是当即反驳。关于这一点，他完全正确。我急匆匆的介入这次讨论只是想证明我的观点才是正确的，而这并不能让我学到什么。&lt;/p&gt;

&lt;p&gt;这是我人生当中一个重要时刻。&lt;/p&gt;

&lt;p&gt;Richard花了整整30年的职业生涯时间来思考这些问题，形成他自己的观点，然而我在几分钟内就立刻进行反驳。放到现在来看，当然他可能是错的，我是对的。但是在你对某件事非常确定你是对的之前，不妨先深入思考下。&lt;/p&gt;

&lt;p&gt;另外问问题和反驳观点之间也有很大的不同，反驳意味着你对自己了解的问题进行了思考，已经形成自己的观点；问问题是说你想要去了解。这个世界如此之大，多多问问题。&lt;/p&gt;

&lt;p&gt;先思考而不是立即反驳是我们一生的追求，这很难。我仍然有时会头脑发热，但是我真的很享受情况变得越来越好时所带给我的好处。&lt;/p&gt;

&lt;p&gt;如果你不确定这一点为什么如此重要，你可以思考一下下面这段Jonathan Ive看待Steve Jobs对Idea是如此珍惜的一段话：&lt;/p&gt;

&lt;blockquote&gt;
And just as Steve loved ideas, and loved making stuff, he treated the process of creativity with a rare and a wonderful reverence. You see, I think he better than anyone understood that while ideas ultimately can be so powerful, they begin as fragile, barely formed thoughts, so easily missed, so easily compromised, so easily just squished.
&lt;/blockquote&gt;

&lt;p&gt;阐述的如此深刻，Idea是如此脆弱，它们开始时显得如此无力，几乎看不见，很容易就被我们忽视了。&lt;/p&gt;

&lt;p&gt;在这个世界上有两件事情看起来是不需要掌握任何技能的：&lt;/p&gt;

&lt;p&gt;花别人的钱；
1、对Idea置若罔闻；
2、错过一个Idea显得如此容易，因为它不牵涉任何工作。难的是你要小心保护它，对它用尽心思，让它生根发芽。
&lt;/p&gt;

&lt;p&gt;所以下次你听到某人说了什么，谈论了什么，或者提出了某个想法，先深入思考五分钟吧，在你狠狠反驳之前，你可能会认为他们说的这些事情太难了，或者有太多的工作需要完成，也许你认为的都对，但也有可能相反：恰好值得一试！&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/10/23/give-it-five-mins.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/10/23/give-it-five-mins.html</guid>
        
        
      </item>
    
      <item>
        <title>React’s diff algorithm(中文版)</title>
        <description>&lt;h3&gt;Something go First&lt;/h3&gt;
&lt;p&gt;这是一篇介绍diff算法的翻译文章，原文来自FB工程师 Christopher Chedeau所写的《React’s diff algorithm》，特此说明，Ok，Here we go.&lt;/p&gt;

&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;React是由Facebook所发起的一个用于构建UI的Js库，创始初衷在于提高Js性能。在这篇文章中，我将使用图文的方式来呈现Diff算法和渲染是如何在React中工作的，并基于此原理，读者可以根据实际情况优化你的应用。&lt;/p&gt;

&lt;h3&gt;Diff Algorithm&lt;/h3&gt;
&lt;p&gt;首先，在正式开始了解React的实现细节之前，让我们从大体上来看下它是如何工作的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/workcode.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在任何时候，你都能通过代码来描述你想要的UI效果。但是请记住，如果你使用了React库来描述你的UI，那么你并不是真正得到了真实页面上的DOM，得到的只是保存在内存中的一些轻量的Js对象，我们把这些对象称之为虚拟DOM。&lt;/p&gt;
&lt;p&gt;React之所以能够大大提高网站性能，是因为React仅仅执行前一页面渲染成后一页面时所需要执行的最少差异动作，省去很多DOM属性值中间变换的渲染过程。&lt;/p&gt;

&lt;h3&gt;逐层比较(Level By Level)&lt;/h3&gt;
&lt;p&gt;在一般情况下，计算任意两棵二叉树之间的最少差异是一个O(n^3)的问题，你可以想象，在React实现中采用这种算法是不可取的，因此React设计了一种时间性能接近O(n)的启发式算法。&lt;/p&gt;
&lt;p&gt;算法原理是&lt;font color=&quot;orange&quot;&gt;React对任意两棵二叉树进行逐层比较，以此来确定这两棵二叉树之间的最少差异数。利用该方法大大降低了比较复杂度，按照通常来理解，这种比较方法是缺乏准确性的，但是在实际应用中观察发现：在DOM树中移动上下级节点的情况是非常少见的，通常只是在同一层的兄弟节点之间移动，&lt;/font&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/level.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;列表(List)&lt;/h3&gt;
&lt;p&gt;假设我们现在有一个组件，在一次迭代循环中，渲染出五个组件，接下去在该组件列表中插入一个新的组件，在信息如此匮乏的情况下，实现两个组件列表之间的映射是一件非常困难的事情。&lt;/p&gt;
&lt;p&gt;在默认情况下，React会把前一个列表中的第一个组件与后一个列表中的第一个组件进行配对，以此类推，当然，你可以为每个组件提供一个Key属性来解决映射问题。在实际应用中，我们能够很容易的在孩子节点中找出唯一的Key，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/list.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;组件(Components)&lt;/h3&gt;
&lt;p&gt;一个React应用通常是由许多用户自定义的组件组成，这些组件最终转化成一棵主要由div(s)组成的DOM树。这一辅助信息被diff算法所很好的利用，因为React通常只比对那些具有相同类的组件。
举例，假设现在Header被一个ExampleBlock所代替，React将会简单粗暴的把Header标签移除，然后创建ExampleBlock，而不会浪费时间去比对这两个毫无相似之处的组件，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/companet.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;事件代理(Event Delegation)&lt;/h3&gt;
&lt;p&gt;为DOM节点设置事件监听器是一件非常耗时和消耗内存的痛苦事。不过，React实现了一项更为流行的技术，叫做&quot;事件代理”，更进一步的是，React还重新实现了一套遵循W3C标准的事件系统，这意味着IE8中原有的事件处理的Bug已成往事，事件名称在各个浏览器之间得以保持一致。&lt;/p&gt;
&lt;p&gt;让我来解释一下这是如何实现的：单事件监听器与文档根节点进行绑定，当触发某一事件时，浏览器给了我们想要的DOM节点。因此，React为了在DOM层级间传播事件，并没有在虚拟DOM层级间迭代循环。&lt;/p&gt;
&lt;p&gt;取而代之的是我们巧妙地利用了每个React组件都有一个编码层级的唯一标示符ID这样一个事实。通过简单的字符串操作我们能很容易的获取到所有父节点的ID。同时把事件监听器放在一个Hashmap中，我们发现这样做的性能远高于把事件监听器与虚拟DOM节点进行绑定。下面的代码展示了事件是如何在虚拟DOM间进行分发的：&lt;/p&gt;
&lt;pre&gt;
// dispatchEvent(&#39;click&#39;, &#39;a.b.c&#39;, event) 
clickCaptureListeners[&#39;a&#39;](event); 
clickCaptureListeners[&#39;a.b&#39;](event); 
clickCaptureListeners[&#39;a.b.c&#39;](event); 
clickBubbleListeners[&#39;a.b.c&#39;](event); 
clickBubbleListeners[&#39;a.b&#39;](event); 
clickBubbleListeners[&#39;a&#39;](event);
&lt;/pre&gt;
&lt;p&gt;浏览器为每个事件和每个监听器都创建一个新的事件对象，这样看起来很好，因为我们能追踪到每个事件对象甚至修改它，然而这也意味着需要许多次的内存分配操作。而React会在应用启动时在内存中分配一个对象池，无论何时需要事件对象，都可以从这个对象池中获取一个可用的事件对象进行复用，这一举措大大降低了垃圾回收的复杂度。&lt;/p&gt;

&lt;h3&gt;渲染(Rendering)&lt;/h3&gt;
&lt;h3&gt;批处理(Batching)&lt;/h3&gt;
&lt;p&gt;无论何时在组件上触发setState方法，React都会把这个组件标记为dirty，等到结束事件循环时，React会对所有标记为dirty的组件进行批处理，重新渲染它们。
该批处理意味着在一个事件循环期间，无论某个DOM元素的属性值被更新过几次，最终在循环结束之后，该属性值只会被渲染一次，这对于构建一款高性能的应用至关重要，而在原生的JS中要实现这个功能却是一项非常困难的工作，而在React应用中，该功能与生俱来，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/batching.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;子树渲染(Sub-tree Rendering)&lt;/h3&gt;
&lt;p&gt;当触发某个组件的setState时，该组件将会为其孩子节点重新构建虚拟DOM。如果你不幸调用了根元素的setState方法，那么整个React应用都将重新渲染，所有组件的render方法都将会被调用，即使这些节点根本就没有发生改变，这听起来很吓人，然而在实际应用中，并不如此，因为我们仅仅只操作了保存在内存中的虚拟DOM，而并没有碰真实的DOM。&lt;/p&gt;
&lt;p&gt;首先，我们正在讨论的是展示用户界面。因为屏幕大小是有限制的，而你通常需要一次性的有顺序的展示上百甚至上千个元素。&lt;/p&gt;
&lt;p&gt;另一个关键点是当你在写React代码时，你并不会常常调用根节点的setState方法。你只对那些受到事件触发的组件进行setState的调用，这意味setState方法的调用常常局限在与用户交互的组件上，很少会调用根节点的setState方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/sub-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;选择性的子树渲染(Selective Sub-tree Rendering)&lt;/h3&gt;
&lt;p&gt;最后，你也可以通过在组件上实现下面的方法来防止其子树进行渲染。&lt;/p&gt;
&lt;pre&gt;
boolean shouldComponentUpdate(object nextProps, object nextState)
&lt;/pre&gt;
&lt;p&gt;基于组件的前后状态，你可以告诉React该组件并没有发生变化，所以无需重新渲染。如果你能够正确使用这项功能，那么这对你应用的性能是一个极大的提升。
为了能够使用该功能，你必须能够比较JS对象，但是这会带来很多问题，比如我们应该进行何种程度的比较，深还是浅，如果进行深层次的比较，那我们也许应该使用不可变的数据结构或者进行深度拷贝。&lt;/p&gt;
&lt;p&gt;并且你还要去考量，如果使用此项了功能，那么我们要确保比较JS对象所带来的计算时间要少于未使用此项功能而需要进行渲染的时间。&lt;/p&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://calendar.perfplanet.com/2013/diff/&quot;&gt;http://calendar.perfplanet.com/2013/diff/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://blog.vjeux.com/&quot;&gt;http://blog.vjeux.com/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/10/19/react-js-arith.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/10/19/react-js-arith.html</guid>
        
        
      </item>
    
      <item>
        <title>Piwik实践入门介绍</title>
        <description>&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;最近团队内部想利用piwik作为网站流量分析工具，刚好借此机会接触之，用过之后才发现，piwik强大又精细，强大之处表现在其功能性完全可以媲美主流的商用流量分析工具，如Google Analystics，百度流量统计等；精细之处表现在给用户很强的惊喜感，体验到很多意想不到的细节，用户接触之后自有体会。可以在线体验：&lt;a href=&quot;http://demo.piwik.org/index.php?module=CoreHome&amp;amp;action=index&amp;amp;idSite=7&amp;amp;period=day&amp;amp;date=yesterday#/module=Dashboard&amp;amp;action=embeddedIndex&amp;amp;idSite=7&amp;amp;period=day&amp;amp;date=yesterday&amp;amp;idDashboard=1&quot;&gt;ONLINE DEMO&lt;/a&gt;，写这篇文章的目的在于总结这几天的学习心得，算是一个回顾，也把在学习研究过程中遇到的困惑进行记录。&lt;/p&gt;

&lt;h3&gt;Install&lt;/h3&gt;

&lt;p&gt;安装分『安装需要满足的条件』和『安装过程』，同时官网还提供了安装视频，这一切尽在：&lt;a href=&quot;http://piwik.org/faq/#installation&quot;&gt;Installation&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;New to piwik&lt;/h3&gt;

&lt;p&gt;官网上该板块的主要目的是带新用户进入piwik的世界，了解piwik的工作机制甚至会涉及到与同类型的流量统计工具的横向比较，是新用户了解piwik的最好实践：&lt;a href=&quot;http://piwik.org/faq/new-to-piwik&quot;&gt;New to Piwik&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;How to&lt;/h3&gt;

&lt;p&gt;该板块主要介绍如何玩转piwik，包括如何定制个性化变量，如何提高piwik运行的性能等等一系列让你更深入玩转piwik的相关建议和最佳实践：&lt;a href=&quot;http://piwik.org/faq/how-to&quot;&gt;How to&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Troubleshooting&lt;/h3&gt;

&lt;p&gt;不管你是新用户还是历史悠久的老用户，这里一定是会来逛逛的，可以说该板块是问题集，遇到问题是不可避免的，不妨来这里看看，或许前人已经给出了很好的解答：&lt;a href=&quot;http://piwik.org/faq/troubleshooting/&quot;&gt;Troubleshooting&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;一些思考的问题（Q&amp;amp;A）&lt;/h3&gt;
&lt;p&gt;
1、访问次数，访客数（独立），浏览次数如何确定？
1）浏览次数基于追踪的js代码有没有被加载，加载则+1，建议把追踪代码放在公共页面；
2）访问次数表示访问被监测网站的用户数（用户不去重）；基于first party uuid和ip，session过期之后，重新生成uuid，访问次数+1；
3）访客数指独立访客数，在访问次数的基础上去掉重复的用户；基于ip地址的启发式算法；
&lt;/p&gt;
&lt;p&gt;
2、PIWIK页面打开速度很慢？
官网提到的可能原因是：在默认情况下，piwik实时处理用户发出的请求（页面点击操作）生成报表进行展示，所以后台计算以及页面渲染展示的时间会比较长。
解决方案是：在crontab中设置定时任务，定时进行报表的归档。理论上可以提高访问速度，设置定时任务。
&lt;/p&gt;
&lt;p&gt;
3、访客数如果想汇总体现，如何在页面提现？
开启相关标志位即可：
&lt;/p&gt;

&lt;pre&gt;
enable_processing_unique_visitors_day = 1
enable_processing_unique_visitors_week = 1
enable_processing_unique_visitors_month = 1
enable_processing_unique_visitors_year = 0
enable_processing_unique_visitors_range = 0
&lt;/pre&gt;

&lt;p&gt;
在默认情况下，出于性能的考虑，piwik关闭了按年和按指定的时间段进行访客数统计的功能，因为按年和按指定时间段进行访客数统计时，需要实时去扫描piwik的log，所以耗时很长，对高流量的网站来说，可能需要长达几分钟的处理时间。
&lt;/p&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;p&gt;http://piwik.org/&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/10/18/piwik-intro.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/10/18/piwik-intro.html</guid>
        
        
      </item>
    
      <item>
        <title>中美日韩四国Github开发者比较</title>
        <description>&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;越来越多的开发者开始使用Github工具，在这之前谁都没法预估一个代码托管网站会收到追捧，受由InfoQ推出的2015年&lt;a href=&quot;http://www.infoq.com/cn/articles/github-chinese-developers-annual-analysis-report&quot;&gt;GitHub中国开发者年度分析报告&lt;/a&gt;的启发，想做一份关于中美日韩（为什么选择这四个国家，理由是这几个国家跟中国的关系最微妙，呵呵，瞎扯，其实我是随便选了这四个国家）四国的开发者比较文章。&lt;/p&gt;

&lt;h3&gt;四国开发者数量比较&lt;/h3&gt;
&lt;p&gt;通过调用Github API来获取每个国家的开发者数量，数据在一定程度上可能会少算导致不够准确，因为API中根据`location`这个属性去定位开发者所属的国家，而`location`这个参数值是可选的，如果开发者未填写此项，那么这部分用户将不会被统计在内。具体发起的HTTP GET请求如下：&lt;/p&gt;
&lt;pre&gt;https://api.github.com/search/users?q=location:china&lt;/pre&gt;
&lt;p&gt;分别获取了这四个国家的开发者数量，虽然数据在某种程度上并不能保证准确，但不影响其参考意义，四国开发者数量对比图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/cukj.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;从上图可以得知，国内开发者数量已经超越美国，处在排头兵的位置，Github在国内开发者社区中的受欢迎程度可见一斑。&lt;/p&gt;

&lt;h3&gt;四国开发者使用语言分布情况&lt;/h3&gt;
&lt;p&gt;通过有针对性的选择当前比较主流的开发语言：Javascript,Java,Php,CSS,Swift,Python,Ruby,Perl,Shell,C，了解四国开发者的语言使用情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/language-china.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;
&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/language-usa.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;
&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/language-japan.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;
&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/language-korea.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以上四图分别展示了中美日韩四国开发者的语言使用情况（备注：开发语言所对应的扇区面积越大，表示对应的开发者数量越多），我们似乎能够比较确信的获知以下几点信息：&lt;/p&gt;

&lt;p&gt;纵观统计图可以发现，前台语言Javascript稳固开发语言第一，Js和Java开发者数量占据所有开发者数量的50%以上，尤其是中韩，两者呈现着势均力敌的效果，而美日两国虽然Js和Java开发者占比很大，但Js明显比Java更受开发者喜爱。&lt;/p&gt;
&lt;p&gt;排在Js和Java语言之后的Python，PHP和Ruby不相上下，PHP一直保留着大块江山，目前已推出PHP7；Python和Ruby作为后起之秀，具备动态快速开发的优势，越来越成为开发者的心头之好。&lt;/p&gt;
&lt;p&gt;样式语言CSS的出现有点出乎意料之外，在老旧的思维习惯里，似乎有点轻视它；但细细想来，在如今把用户体验当尚方宝剑的产品设计里面，样式不重要才见的奇怪呢，不知从哪年起，UX方面的人才突然变得非常受欢迎，同时轻框架，重设计的提倡也带来用户体验的变革，这对用户来说必然是一件好事，同时也傲娇到再也不需要去迎合老旧，土鳖的设计习惯，因为当下应用产品正在经历着从匮乏到丰富到五彩缤纷到争雄逐鹿到你死我活的变革，真是虐死一堆产品汪的节奏。好了，有点跑题，只是想说UX被越来越重视着。&lt;/p&gt;
&lt;h3&gt;Github中国开发者区域分布图&lt;/h3&gt;
&lt;p&gt;这似乎是一个已知的事实，用下面的这幅图说话吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;/assets/images/2015/10/china-fenbu.png&quot; alt=&quot;&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;没有歧视其他省份开发者的意思，只是有针对性的选择了这几个我认为开发者相对集中的区域（见着色区域，颜色越深，代表开发者数量越多），这幅图不过是在确认一个事实：北上广深依然有绝对优势的开发者，这些一线城市凭借其综合因素仍然吸引着大批开发者前往，但不可否认的是杭州作为一座时尚美丽干净的城市，尤其是近几年互联网的火热让杭州有赶超一线城市开发者的趋势。&lt;/p&gt;

&lt;h3&gt;Ending&lt;/h3&gt;
&lt;p&gt;这只是作为我业余时间产生的一个衍生品，数据来自官方（All Data From Github），但不代表任何人，任何组织，我只是觉得好玩而已，并且这篇文章也只是从量上进行一个横向比较，没多少有价值的东西，业余有精力再多挖掘一点有意思的东西分享给大家，就这样。&lt;/p&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;pre&gt;
1、http://ecomfe.github.io/echarts/index-en.html
2、https://developer.github.com/v3/search/
&lt;/pre&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/10/15/github-developers.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/10/15/github-developers.html</guid>
        
        
      </item>
    
      <item>
        <title>设计心理学笔记</title>
        <description>&lt;p&gt;作为学设计必须要看的书之一，《设计心理学1-日常心里学》真的是一本教科书般的存在，是真的很枯燥吧，好像不至于，至少我开始看的时候居然有点津津有味，好变态啊。 
其实整本书偏理论，学习设计最最重要的不是工具怎么用，会画，会临摹成千上万幅的作品，还是不如好好的设计，好好的去创作属于自己的作品。设计也并非艺术，好的设计当然可以成为艺术，但设计更重要的是其背后的逻辑，思维以及原理。&lt;/p&gt;

&lt;h2 id=&quot;the-psychopathology-of-everyday-things&quot;&gt;一， 日用品心理学 （The Psychopathology of Everyday Things)&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;好设计的两个重要特征：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;可视性（discoverability)：所设计的产品能不能让用户明白怎样操作是合理的。&lt;/li&gt;
  &lt;li&gt;易通性(understanding)：所有设计的意图是什么，产品的预设用户是什么，所有不同的控制和装置起什么作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;书中关注的三大设计的领域&lt;/h3&gt;
&lt;p&gt;设计关注物品是如何运转，如何操控，以及人和技术之间互动的机理。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;工业设计：是一种专业的服务，为使用者和生产者双方的利益而创造和开发产品与系统的概念和规范，旨在优化功能，价值和外观。&lt;/li&gt;
  &lt;li&gt;交互设计：重点关注人与技术的互动。&lt;/li&gt;
  &lt;li&gt;体验设计：设计产品，流程，服务，以及时间和环境的实践，注重关注整体体验的质量和愉悦感&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;以人为本的设计&lt;/h3&gt;

&lt;p&gt;以人为本的设计理念意味着设计以充分了解和满足用户的需求为基础。
以人为本的设计就是尽可能的避免限定的问题，然后不断反复验证，寻找问题的真相。解决方法就是快速测试不同的概念，每次测试后都有所改进，从而找到问题梭子。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;交互设计的基本原则&lt;/h3&gt;

&lt;p&gt;1） 示能（affordances）：&lt;/p&gt;

&lt;p&gt;指一人无力对象鱼人之间的关系（无论是动物还是人类，甚至机器和机器人，它们之间发生的任何交互作用）
示能是物品的特性与决定物品预设用途的主题的能力之间的关系。 
如果示能和反示能不能够被察觉到，就需要标识出来。
示能是存在的，即使他们是不可见的。对于设计师来说示能得可见性至关重要：可见的示能对操控提供了有力的线索。
不需要标签或说明书的帮助，预设用途（ Perceived affordances)帮助人们了解采取什么行动来操作。 
我们把示能得符号提示功能叫做意符。&lt;/p&gt;

&lt;p&gt;2） 意符（Signifiers)&lt;/p&gt;

&lt;p&gt;示能决定可能进行哪些操作。
意符则点明操作的位置。
示能解释了世界上作为主题的人，动物或机器如何与其他东西进行互动的可能性。一些示能是可感知的，其他则是不可见的。
意符是信号。一些意符是生活中得符号，标签和图样。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;示能是人和环境之间可能的互动，有些是可见的有些不是。&lt;/li&gt;
  &lt;li&gt;预设的用途经常表现为意符，但经常模棱两可。&lt;/li&gt;
  &lt;li&gt;意符是一种提示，特别告诉用户可以采取什么行为，以及应该怎么操作。 意符必须是可感知的，否则它们不起作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3） 映射（Mapping）
映射表示两组实物要素之间的关系。
当一系列可能的操作是可见的，当控制和显示契合自然映射时，设备就会容易使用。&lt;/p&gt;

&lt;p&gt;4） 反馈（Feedback)
反馈- 沟通行动的结果
反馈必须是即时的。
过多的反馈可能比过少的反馈更加恼人。
反馈需要精心策划，需要以一种不显著的方式确认所以的操作。&lt;/p&gt;

&lt;p&gt;5） 概念模型（Conceptual Models)
概念模型通常是高度简化的说明，告诉你事物是如何工作的。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;系统映像&lt;/h3&gt;
&lt;p&gt;我们把提供给用户的使用信息组合叫做“系统映像”&lt;/p&gt;

&lt;p&gt;设计师的概念模型的设计师观看，感受和操作产品时的想法。&lt;/p&gt;

&lt;p&gt;系统映像来自其物理结构（包括文档）。通过与产品和系统映像的互动产生了用户的心理模型。&lt;/p&gt;

&lt;p&gt;设计是期望用户的模型与自己的模型完全相同，但是因为他们不能直接同用户沟通，沟通的重担就转移到系统映像上。&lt;/p&gt;

&lt;p&gt;良好的概念模型是产品易于理解，令人愉悦的关键：良好的沟通是建立良好的概念模型的关键。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;二， 日常行为心理学&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;用户使用物品时，面对的两个心理鸿沟：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;执行的鸿沟 （用户试图弄清楚如何操作）&lt;/li&gt;
  &lt;li&gt;评估的鸿沟 （试图弄清楚操作的结果）
&lt;strong&gt;设计师的作用是帮助使用者消除这两个鸿沟&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;如何消除这个心理鸿沟&lt;/h4&gt;
&lt;p&gt;使用意符，约束，映射和概念模型来消除执行的鸿沟，用犯规和概念模型来消除评价的鸿沟。 
### 行动的七个阶段&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;行动有两个步骤：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;执行动作&lt;/li&gt;
  &lt;li&gt;评估结果，然后给出解释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;行动的七个阶段（一个是目标，三个执行步骤，和三个评估步骤）&lt;/h4&gt;
&lt;p&gt;执行和评估需要达成共识：事物如何工作以及产生结果是否一致，执行和评估会影响我们的情绪状态。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;目标（确立意图）&lt;/li&gt;
  &lt;li&gt;计划（确定方案）&lt;/li&gt;
  &lt;li&gt;确认（行动顺序）&lt;/li&gt;
  &lt;li&gt;执行（实施行动）&lt;/li&gt;
  &lt;li&gt;感知（外部世界的状态）&lt;/li&gt;
  &lt;li&gt;诠释 (知觉作用）&lt;/li&gt;
  &lt;li&gt;对比（目标与结果）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;驱动型的行动&lt;/strong&gt;
行动发端于一个新的目标，即从顶部开始。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;机会主义&lt;/strong&gt;
对于多日常任务来说，目标和意图并不明确。机会主义是指充分利用形势的行为。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;人的思想：潜意识主导&lt;/h3&gt;

&lt;p&gt;潜意识思维匹配模式，就是找到过去经验与当前状况最佳匹配。
潜意识思维偏重规则和结构，在正式场合使用会受限制。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;人得认知和情感&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本能层次&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最基本的处理层次被称为本能&lt;/li&gt;
  &lt;li&gt;本能层次仅仅简单的评估周围的状况，不会探讨根源，没有责备，也没有表扬。&lt;/li&gt;
  &lt;li&gt;本能层次与身体的肌肉-运动系统紧密相连&lt;/li&gt;
  &lt;li&gt;本能反应是迅速的，完全是潜意识的。&lt;/li&gt;
  &lt;li&gt;事物的外在表现出发本能反应。 这与产品的可用性，有效性或者可理解性无关，只关于吸引或厌恶。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;行为层次&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行为层次是学习能力之本。&lt;/li&gt;
  &lt;li&gt;对设计师来说，行为层次最重要，是要让每一个行动都与一个期望相关联。如果期待一个积极的结果，其结果就是一个积极的情感反应（正价反应），反之则是负价反应。&lt;/li&gt;
  &lt;li&gt;行为状态是可以习得的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺乏犯规会导致失控的感觉，这可能让人感到不安。 
反馈是管理预期的关键。犯规，即对结果的预知，是满足期望，学习和发展熟练行为的关键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反思层次&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;反思层次是有意识的认知之本。因此这是发展深层理解的地方。是产生推力和有意识决策的地方。&lt;/li&gt;
  &lt;li&gt;反思层次是认知的，有深度的缓慢的。&lt;/li&gt;
  &lt;li&gt;反思让我们评价某个产品，推荐给其他人使用，或者不建议使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本能，行为，反思三个层次一起发挥作用。 行为层次是交互体验之本，也是所有基于期望的情感，即希望和喜悦挫折和愤怒之本。&lt;/p&gt;

&lt;p&gt;对实物的理解产生于行为和反思层次的结合。&lt;/p&gt;

&lt;p&gt;高层次的反思认知一颗出发低层次的情绪。低层次的情绪会引发更高层次的反思认知&lt;/p&gt;

&lt;h3 id=&quot;flow&quot;&gt;心流（Flow)&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;我们热衷于从事的活动&lt;/li&gt;
  &lt;li&gt;我们会专注一致的活动&lt;/li&gt;
  &lt;li&gt;有清楚目标的活动&lt;/li&gt;
  &lt;li&gt;有立即回馈的活动&lt;/li&gt;
  &lt;li&gt;我们对这项活动有主控感。&lt;/li&gt;
  &lt;li&gt;在从事活动时，我们的忧虑感会消失。&lt;/li&gt;
  &lt;li&gt;在活动时，主观的时间会改变。&lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;section-12&quot;&gt;自说自话&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;概念模型是一种形式的故事来自我们习惯寻找解释的天性。&lt;/li&gt;
  &lt;li&gt;概念模型通常由零碎的事实结构，很了解所发生的事情，用一种天真的心理学来推断原因，机制的相互关系，即使有时候没有任何关联。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;责备错误之事&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;人们试图发现事件发生的原因，当两件事情相继发生时，他们容易认为期间含有因果关系。&lt;/li&gt;
  &lt;li&gt;人们很自然的将自己的不幸归咎于周围环境，将别人的不幸归咎于他们的个性。&lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;learned-helplessness&quot;&gt;习得性无助(Learned helplessness)&lt;/h4&gt;
    &lt;p&gt;指人们在座某事时多次经历失败，便认为自己无法做好这件事情，结果陷入无助的状态。 
#### 积极心理学&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;经常失败，快速失败&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当用户不能正确使用你的产品时，不要责怪他们&lt;/li&gt;
  &lt;li&gt;把用户遇到的困难当做产品改善的机会。&lt;/li&gt;
  &lt;li&gt;消除电子设备或计算机系统的所有错误信息，而不是提供帮助和指导。&lt;/li&gt;
  &lt;li&gt;直接从帮助和指导信息中纠正问题。让用户能继续使用产品：不要停步–帮助用户顺利，持续的使用。不要让用户重新开始。&lt;/li&gt;
  &lt;li&gt;假设用户所做的不完全是正确的，如果有部恰当的地方，提供指导，使他们能纠正问题，找到正确的方式。&lt;/li&gt;
  &lt;li&gt;面对你自己要和打交道的人，积极地思考。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-14&quot;&gt;不当的自责&lt;/h3&gt;
&lt;p&gt;消除“人为差错”这个词，取而代之的是谈论沟通和互动，我们所说的差错通常是不了的沟通或互动造成的。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;七个基本的设计原则&lt;/h3&gt;
&lt;p&gt;行动的七个阶段提供的一个基本问题清单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;想实现什么&lt;/li&gt;
  &lt;li&gt;可能替代的动作序列是什么&lt;/li&gt;
  &lt;li&gt;现在能做什么&lt;/li&gt;
  &lt;li&gt;该怎么做&lt;/li&gt;
  &lt;li&gt;出什么事了&lt;/li&gt;
  &lt;li&gt;这是什么意思&lt;/li&gt;
  &lt;li&gt;做好了么，已经达到目标了么&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;有助于回答执行类的信息叫前馈（feedforward),有助于理解发生了什么的信息叫做反馈（feedback)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设计的基本原则：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可视性： 让用户有机会确定哪些行动是合理的，以及呈现该设备的当前状态。&lt;/li&gt;
  &lt;li&gt;反馈：关于行动的后果，以及产品或服务当期那状态的充分和持续的信息。当执行了一个动作之后，很容易确定新的状态。&lt;/li&gt;
  &lt;li&gt;概念模型：设计传达所有必要的信息，创造一个良好的系统概念模型，引导用户理解系统状态，带来掌控感。概念模型同时包括可视性，和评估行动的结果。&lt;/li&gt;
  &lt;li&gt;示能： 设计合理的示能，让期望的行动能够实施。&lt;/li&gt;
  &lt;li&gt;意符： 有效使用意符确保可视性，并且很好的沟通和理解反馈。&lt;/li&gt;
  &lt;li&gt;映射： 使控制和控制结果之间的关系遵循良好的映射原则，尽可能的通过空间布局，和时间得连续来强化映射。&lt;/li&gt;
  &lt;li&gt;约束： 提供物理，逻辑，语义，文化的约束来指导行动，容易理解。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-16&quot;&gt;三，头脑中的知识与外界知识&lt;/h2&gt;

&lt;h3 id=&quot;section-17&quot;&gt;含糊的知识引导精确的行为&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;知识同时储存于头脑中和外部世界里。
脑海中的知识与外界信息的相互结合，决定了行为的方向。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;无需具备高度精确的知识。&lt;/li&gt;
  &lt;li&gt;外界存在自然约束条件。&lt;/li&gt;
  &lt;li&gt;头脑中有关于文化规范与习俗的知识。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;人类行为由内在（头脑）和外部知识与规范共同决定。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;储存于外界的知识&lt;/h3&gt;

&lt;p&gt;一旦从事某项任务所需要的知识在外界垂手可得，学习这些信息的必要性就会大幅度的降低。
人们依赖两种类型的知识完成工作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;是什么 –陈述性知识（declarative knowledge)(知识未必求真）&lt;/li&gt;
  &lt;li&gt;怎么做 –程序性知识(procedural knowledge)
程序性知识很难甚至不可能用文字表述清楚。最佳的学习方法是联系&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-19&quot;&gt;不需要高度精确的知识&lt;/h3&gt;
&lt;p&gt;通常人们在座判断时不需要精确的知识，人们所需要的是结合外界的与头脑中的知识来作清楚的决定。 
### 依靠约束简化记忆
约束因素本身并不能决定哪一种安装方法是对的，错误在所难免，但却能减轻学习负担。
###记忆的结构
&lt;strong&gt;短时记忆&lt;/strong&gt;
短时记忆或工作记忆储存的是当前最新的经验或思索内容，是刚产生的记忆。&lt;/p&gt;

&lt;p&gt;对短时记忆系统造成的约束来源于干扰任务，可以通过使用多种感官的方法来减轻。
为了最大先动的提高工作记忆的效率，最好用不同的模式呈现不同的信息，像视觉，触觉，听觉，空间位置以及手势等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;长时记忆&lt;/strong&gt;
长时记忆储存的是过去的信息。 长时记忆的主要困难在于组织管理。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随意的记忆&lt;/li&gt;
  &lt;li&gt;有意义的记忆&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-20&quot;&gt;近似模型：现实世界里的记忆&lt;/h3&gt;
&lt;p&gt;简化思想的一种方式及时使用简化的模型，即近似模拟事情的真实基本状态。 
科学探究真理，从而时间应对混沌。从业人员不需要真相，他们需要快速得到结果，即便这些结果不准确，只要可以应用，能到到目的就“足够好”。&lt;/p&gt;

&lt;p&gt;在真实的，现实的世界里，我们不需要绝对的真理：近似模式就工作的很好。 每个近似模型可能不对，但都有效的减轻了思维的负担，以便快速地得到结果，准确度“足够好”就行。&lt;/p&gt;

&lt;h3 id=&quot;section-21&quot;&gt;头脑中得知识&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;前瞻记忆（prospective memory)
记住在未来某个时间要从事的一些活动&lt;/li&gt;
  &lt;li&gt;未来记忆 (memory for the future)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规划能力，想象未来的能力。&lt;/p&gt;

&lt;p&gt;提醒的两个层面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;信号：有件事要记住&lt;/li&gt;
  &lt;li&gt;信息：这件事是什么
理想的提醒方法必须同时具备信号和信息两个方面，即有件事要记住和这件事是什么。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-22&quot;&gt;外界知识和头脑中的知识&lt;/h3&gt;

&lt;p&gt;储存于外界的知识具有自我提醒功能，它帮助我们回忆起容易遗忘的内容。 
存于头脑中得知识使用起来很搞笑，它无需外部环境进行查找和诠释。可是想要利用头脑中得知识我们必须先通过学习，才能将其储存在头脑中。&lt;/p&gt;

&lt;h3 id=&quot;section-23&quot;&gt;自然映射&lt;/h3&gt;
&lt;p&gt;自然映射是那些显而易见的映射关系，作用于控制与被控制对象之间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最佳映射：控制组件直接安装在被控制对象上&lt;/li&gt;
  &lt;li&gt;次好映射：控制组件尽量靠近被控制的对象&lt;/li&gt;
  &lt;li&gt;第三号的映射：控制组件与被控制对象的空间分布一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-24&quot;&gt;四， 知晓：约束，可视性和反馈&lt;/h2&gt;
&lt;p&gt;外部世界里的知识： 即使遇到一个从不熟悉的设备或状况，设计师如何提供重要的信息，一遍人们知道怎么操作。&lt;/p&gt;

&lt;p&gt;怎么做到呢： 将每一个零件的物理约束，与文化，语义或路基的约束因素综合考虑就行。&lt;/p&gt;

&lt;p&gt;比如拼装乐高玩具：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;物理限制约束了多种可能的安装位置。&lt;/li&gt;
  &lt;li&gt;文化和语义的约束提供了进一步确认的线索。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-25&quot;&gt;四种约束因素&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;四种约束因素： 物理结构，语义，文化，和逻辑。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;约束是非常有力的线索，限定了一系列可能的操作。在设计中有效使用约束因素，即使在全新的情境下，也能够让用户轻而易举的找到合适的操作方式。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;物理约束&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;物理结构上的局限性将可能的操作方法限定在一定的范围内。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;文化约束因素&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每种文化都有一套社交行为准则。 
文化行为准则的范式(Schemas）也就是知识结构，由一般规则和信息组成。 主要用于诠释状况，指导人们的行为。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;语义约束
语义约束是指利用某种情况的特殊含义来限定可能的操作方法。&lt;/li&gt;
  &lt;li&gt;逻辑约束&lt;/li&gt;
  &lt;li&gt;文化规范，习俗和标准&lt;/li&gt;
  &lt;li&gt;习俗实际上是一种文化的约束，通常与人们的行为方式相联系&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;activity-centered-control&quot;&gt;以活动为中心的约束 (activity-centered control)&lt;/h3&gt;

&lt;p&gt;一个近似的错误的方法是以设备为中心的约束，当以设备为中心控制，就会有不同的控制屏去管理灯光，音响，电脑。。。&lt;/p&gt;

&lt;h3 id=&quot;section-26&quot;&gt;引导行为的约束力&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;强制功能
强制功能是一种物理约束，在行动受限的情况下，出现在某个阶段的差错不会蔓延，能防止产生进一步的后果。 
强制功能是较强的约束的极端情况，可以防止不当的行为。 
强制功能的其他形式：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;互锁&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;互锁促使行动按照正确的次序进行。 比如微波炉和其他内部存在高电压设备，可防止有人在美断开电源的情况下打开炉门或拆卸设备。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;字锁&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;自锁保持一个操作停留的激活的状态，防止有人过早的停止操作。 例如： 计算机总中得提示功能，询问是否真的想要退出。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;反锁
相较于自锁是是某人待在一个空间，或在所需要操作完成前防止误操作，反锁则是防止某人进入那些危险区域，或者阻止事情的发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;惯例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在设计中保持一致性很有效，这意味着在一个系统中已经习惯的知识可以被轻而易举地带到另一个系统。 
总得来讲，应该遵守一致性。如果用新的方式做一件事只比原来好一点，那么最好与以前保持一致。如果必须做出改变，那么每个人都得改变。
新旧混杂的系统让每个人困惑。当新的做事方式明显优于旧的方式，那么因改变而带来的价值会超越本身所带来的困难。不能因为某样东西与众不同就认为它好。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用声音作为意符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候并非每件物品都要被设计的可见。那就利用声音：没有其他方法时，声音能够提供有用的信息。 声音可以告诉我们产品的运转是否正常。&lt;/p&gt;

&lt;h2 id=&quot;section-27&quot;&gt;五， 人为差错？不，拙劣的设计&lt;/h2&gt;
&lt;p&gt;设计师能够很好的理解物理约束，但经常严重地误解心里的局限。我们应找到根本原因，重新设计系统，保证不再发生同样地问题。 
### 根本原因分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;詹姆斯.里森原则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常会有多个事情出错，或者多个事件，只有要他们中得任何一个没有发生，就不会发生事故。
当发现人为差错可能是因素之一，我们应该继续分析并找到为什么会发生差错，可以做些什么防止它再次发生。&lt;/p&gt;

&lt;h3 id=&quot;section-28&quot;&gt;五个为什么&lt;/h3&gt;

&lt;p&gt;普遍存在这种倾向，一旦发现人为差错，就停止寻找深层次原因。&lt;/p&gt;

&lt;p&gt;“五个为什么”意味着寻找原因时，即使你已经找到了一个，不要停下来，要问问为什么是这个原因。&lt;/p&gt;

&lt;h3 id=&quot;section-29&quot;&gt;差错的两种类型： 失误，错误。&lt;/h3&gt;

&lt;p&gt;差错是所有错误行为的总称
&lt;strong&gt;失误：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当目标正确，但要求的行动没有合理地完成，就造成了失误，即执行有瑕疵。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行动失误&lt;/li&gt;
  &lt;li&gt;记忆失效&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;失误的特性： 与新手相比，越是熟练的人失误越多，常见原因是注意力不集中。一些失误是由动作之间的相似性造成的。 
与设计相关的三类失误：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;撷取性失误(capture slips)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指的是某个经常做的动作，或刚刚做过的动作突然取代了想要做的动作，即某个曾经的动作挤占了需要完成的动作。 
设计师要避免有相同的起始步骤，然后再发散的流程。 只要可能，应该从一开始就设计出不同的动作序列。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;描述相似性失误( description-similarity slips)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在描述性失误中，差错发生在目标相似的对象上。如果对目标面熟相当的含糊不清，就会发生描述相似性失误。 
 在设计不同目的的控制和显示设备时，设计师需要确认它们之间具有明显的差异。 看上去完全相同的开关或显示，一行行排列在意洽很容易导致描述相似性失误。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;记忆失效性失误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;防止记忆失效引起的失误&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用最少的步骤&lt;/li&gt;
  &lt;li&gt;对需要完成的步骤提供生动有效的提醒。&lt;/li&gt;
  &lt;li&gt;强制功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;功能状态失误 （mode errors)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当设备有不同状态，而相同的控件有不同的含义，就可能发生功能状态失误。 
设计者必须尽量避免模式控制的设计，如果必须这样做，则必须使设备能够明显地显示所激活的功能模式。 再者设计师必须经常设计出可以抵消干扰活动对已设定模式带来影响的系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;错误&lt;/strong&gt;
当目标和计划更本就不对，就会发生错误。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;违反规则&lt;/li&gt;
  &lt;li&gt;缺乏知识&lt;/li&gt;
  &lt;li&gt;记忆失效
设计师应该假设人们在行动中可能被打断，在恢复操作时他们可能需要帮助。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;失误是下意识地行为，却在中途出了问题。错误则产生于意识行为中。 意识行为让我们具有创造力和洞察力，能从表面上毫不相关的实物中看出它们的联系，并使我们更具部分正确的，甚至是错误的证据迅速得出正确的结论。&lt;/p&gt;

&lt;h3 id=&quot;section-30&quot;&gt;为差错设计&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;了解差错的更本原因，通过设计以尽量减少这些诱因。&lt;/li&gt;
  &lt;li&gt;进行合理性检验。检查操作行为是否能够通过“一般性常识“的测试？&lt;/li&gt;
  &lt;li&gt;设计出可以”撤销“操作的功能–“返回”以前操作，或者如果操作不能“返回”，则增加该操作的难度。&lt;/li&gt;
  &lt;li&gt;让人们易于发现一定会出的差错，以便容易纠正。&lt;/li&gt;
  &lt;li&gt;不要把操作看成是一种操作，相反，帮助操作者正确的完成动作。应该将操作文卫近似于预期目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;差错的信息确认：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使正确的操作对象更加现眼。改变正在操作的外观使其更加现眼：放大，或者改变颜色。&lt;/li&gt;
  &lt;li&gt;让操作可逆： 如果用户要保存内容，除了不厌其烦的再次打开要保存的文件，不能发生任何损失。如果用户选择不保存，系统能够秘密地保存内容，等到下次用户再打开文件时，询问是否恢复为最近的版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-31&quot;&gt;从差错到事故–瑞士奶酪模型&lt;/h3&gt;

&lt;p&gt;发生事故通常有多重因素，任何其中一个因素不出现，事故就不会发生。
我们应用一下几种方式减少事故：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;增加更多层的奶酪&lt;/li&gt;
  &lt;li&gt;减少孔洞的数量（或者让现有的孔更小一些）&lt;/li&gt;
  &lt;li&gt;如果一些孔洞将要排成一线，提醒操作者。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-32&quot;&gt;应对差错的设计原则&lt;/h3&gt;
&lt;p&gt;我们所说的“认为差错” 往往只是一种人类特性与技术需求不相符的行动。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将所需的操作只是储存在外部世界，而不是全部储存在人的头脑里，但是如果用户已经把操作步骤熟记在心，应该能够提高操作的效率。&lt;/li&gt;
  &lt;li&gt;利用自然和非自然的约束因素，例如物理约束，逻辑约束，语义约束和文化约束，利用强迫性工恩呢刚和自然匹配的原则。&lt;/li&gt;
  &lt;li&gt;缩小动作执行阶段和评估阶段的鸿沟。 在执行方面，要让用户很容易看到哪些操作是可行的。在评估方面，要把每一个操作的结果显示出来，使用户能够方便，迅速，准确地判系统的工作状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-33&quot;&gt;六， 设计思维&lt;/h2&gt;
&lt;p&gt;在现实世界里，问题不会像学习材料上的那样亲切友好，干净整洁的来到你面前。你需要探究问题的来源。你仅仅看到表面现象，从不深究真正的问题所在，这样就太容易了。&lt;/p&gt;

&lt;h3 id=&quot;section-34&quot;&gt;解决真正的问题&lt;/h3&gt;
&lt;p&gt;设计师拿到一个问题，应首先发散式思考，而不是聚焦于解决问题，先做用户研究，搞清楚要实现什么，产生一个又一个新的点子。&lt;/p&gt;

&lt;h3 id=&quot;section-35&quot;&gt;设计思维的两大工具：以人为本的设计思想，双钻（发散-聚焦）设计模式。&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;双钻设计模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;设计的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“发现”&amp;amp;“定义”确认正确问题的发散和聚焦阶段。&lt;/li&gt;
  &lt;li&gt;“开发”&amp;amp;“交付”制定正确方案的发散和聚焦阶段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.以人为本的设计流程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;找到正确的问题&lt;/li&gt;
  &lt;li&gt;满足用户需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以人为本设计流程的四个步骤&lt;/p&gt;

&lt;p&gt;1） 观察&lt;/p&gt;

&lt;p&gt;2） 激发创意&lt;/p&gt;

&lt;p&gt;3） 打样&lt;/p&gt;

&lt;p&gt;4） 测试&lt;/p&gt;

&lt;p&gt;观察潜在目标人群，激发创意，然后测试。不断循环这个过程，直到满意为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;观察&lt;/strong&gt;
客户研究非常关键的一点就是观察目标用户的行为，在自然状态下，在他们的日常生活中，以及正在设计的产品或服务将来实际应用的场合。 
调研对象应当与潜在用户一致。 
设计调研：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找出正确的问题，要求深入了解用户的真实需求。&lt;/li&gt;
  &lt;li&gt;深入了解潜在用户群的行为方式。
设计调研与市场调查&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个成功产品的需求：&lt;/p&gt;

&lt;p&gt;如果没有人买它，那么一切都没有意义。产品设计必须提供影响用户购买决定的所有要素。&lt;/p&gt;

&lt;p&gt;一旦用户购买的产品，开始使用，产品应该能满足用户的真实需求，人们才会使用和了解。&lt;/p&gt;

&lt;p&gt;设计规范必须包括所有这些要素：市场和设计，购买和使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;激发创意（idea generation)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;激发足够数量的创意。&lt;/li&gt;
  &lt;li&gt;创意，不要受限制。避免批评任何的电子。&lt;/li&gt;
  &lt;li&gt;质疑每一件事。愚蠢的问题可能会触及事情的本质。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;打样&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想知道一个穿衣是否合理，唯一的方法就是侧hi。 对每一个可能的解决方案制作快速模型或实物模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重复&lt;/strong&gt;
以人为本的设计原则中，重负能够促使设计持续的改进和加强。&lt;/p&gt;

&lt;h3 id=&quot;section-36&quot;&gt;以活动为中心的设计和以人为本的设计&lt;/h3&gt;

&lt;p&gt;Activity-centered design
让操作方式来定义产品和结构，一句操作的概念模型来建立产品的概念模型。
以活动为中心的设计就是以人为本的设计思路，尤其适用于大量的各种各样的目标人群。&lt;/p&gt;

&lt;h3 id=&quot;section-37&quot;&gt;任务和活动的区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一项活动通常包含一系列的任务，但所有的任务都向着一个共同的目标，更高层次的目标。
任务是有组织的，紧密结合的一系列操作。
良好的设计的设备，能够将支持任务所需要的各种各样的活动，整合在一起，做到彼此无缝过度，确保为某一个任务所进行的工作不会影响到另外一个任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;活动&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;活动是分等级的。高层次的活动可以被分解成置于其下得无数低层次的活动。
低层次的活动会产生大量的“任务”，这些任务最终被基本的“操作”来执行。&lt;/p&gt;

&lt;h3 id=&quot;section-38&quot;&gt;循环往复的设计流程与线性流程&lt;/h3&gt;

&lt;p&gt;结合两个流程的长处：循环往复的提炼问题，改善方案，在流程的关口处结合阶段评审。
延迟对产品需求进行精确定义，知道对快速样品的反复测试结束，同时保持对时间计划，预算和质量进行严格控制。&lt;/p&gt;

&lt;h3 id=&quot;section-39&quot;&gt;为特殊人群设计&lt;/h3&gt;

&lt;p&gt;为特殊人群设计通常称作“和合设计”（inclusive design) or “普遍设计”（universial design)
这种设计通常会让每个人都受益。&lt;/p&gt;

&lt;h3 id=&quot;section-40&quot;&gt;复杂是好事，混乱惹麻烦&lt;/h3&gt;

&lt;p&gt;复杂擦能让我们应对所参与的行动，繁杂性，可以说成“混乱”。如何才能避免混乱才是设计师发挥技巧的舞台。&lt;/p&gt;

&lt;h3 id=&quot;section-41&quot;&gt;标准化和技术。&lt;/h3&gt;

&lt;p&gt;产品的改良来自技术的自然演变，有时则来自产品的标准化（eg:汽车）
标准化你的生活会简单，每个人只需要学习一次，标准化要掌握实际，不能过早进行标准化，否则你可能会被禁锢在不成熟的技术之中。&lt;/p&gt;

&lt;h3 id=&quot;section-42&quot;&gt;故意制造困难&lt;/h3&gt;

&lt;p&gt;我们有时候必须忽视优良设计的原则，否则那些用户保密的产品就会丧失其存在的价值。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这类物品并没有完全排斥易用性，设计人员通常把物品的某一部分设计的很难使用。&lt;/li&gt;
  &lt;li&gt;即便要增加使用某类物品的难度，也要让用户知道如何操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-43&quot;&gt;七，全球商业化中的设计&lt;/h2&gt;

&lt;h3 id=&quot;section-44&quot;&gt;在真空中进行以人为本的设计&lt;/h3&gt;
&lt;p&gt;不考虑真实世界中的竞争，成本和时间。&lt;/p&gt;

&lt;h3 id=&quot;section-45&quot;&gt;影响产品开发的过程：&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;功能主义(featuritis)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;现有的用户喜欢这个产品，但表达愿望–希望更多的特色，功能，性能&lt;/li&gt;
  &lt;li&gt;一个处于竞争中得公司，正在给自己的产品增加新功能，给竞争对手带来更多的竞争压力，单页给公司在竞争中领先提供优势&lt;/li&gt;
  &lt;li&gt;用户很满意，单销售在下降，因为市场在饱和：每个想要的人已经拥有了它。是时候加强它的功能，增加一点亮点，这样能够吸引用户购买新的型号，升级旧版产品。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;功能蔓延（creeping featurism)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;优秀的产品设计需要从竞争的压力中抽身出来，确保整个产品风格一致，结构明晰，易于学习。&lt;/p&gt;

&lt;h3 id=&quot;section-46&quot;&gt;产品创新与设计的两种形式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;渐进式创新 – 登山法（hill climbing)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;渐进式创新从现有的产品开始，使之更加完善。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;颠覆式创新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;颠覆式创新则是全新的，经常来自能够衍生新功能的新技术。&lt;/p&gt;

&lt;p&gt;颠覆式创新在改变着我们的生活和行业，渐进式创新让产品更完善。&lt;/p&gt;

&lt;h3 id=&quot;section-47&quot;&gt;竞争压力&lt;/h3&gt;

&lt;p&gt;价格&amp;gt;功能&amp;gt;质量&lt;/p&gt;

&lt;h3 id=&quot;section-48&quot;&gt;从想法变成产品需要很长的时间&lt;/h3&gt;
&lt;p&gt;科技发展迅速，但人类和文化在缓慢改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只有当最终产品成功，设计才是成功的，产品成功意味着人们购买产品，使用它，分享他，然后传播到全世界。人们不肯购买产品就是失败的设计，无论设计团队认为它又多么的出色。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这篇读书笔记从9月4号断断续续的写道现在才完成。 在整理的过程中，可以更加全面宏观的去看整本书。 
这亦可以拿来做检索。&lt;/p&gt;

</description>
        <pubDate>Sat, 03 Oct 2015 20:12:12 +0800</pubDate>
        <link>http://pandaqr.github.io/2015/10/03/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6-%E7%AC%94%E8%AE%B0.html</link>
        <guid isPermaLink="true">http://pandaqr.github.io/2015/10/03/%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A6-%E7%AC%94%E8%AE%B0.html</guid>
        
        
      </item>
    
  </channel>
</rss>
