<!DOCTYPE html>
<html>
<head>   
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Rock's personal notebook - Blogging something deserved</title>
    <meta name="description" content="Your New Jekyll Site, Blogging about stuffs" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />

    <!-- This is for syntax highlight -->
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css">
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />

</head>
<body class="home-template">

    
    <main class="content" role="main">

    <article class="post">
        <header class="post-header">
            <a id="blog-logo" href="http://rulerstorm.github.io">
                
                    <span class="blog-title">Rock's personal notebook</span>
                 
            </a>
        </header>
        
        <span class="post-meta">
        	<time datetime="2014-11-09">09 Nov 2014</time>
        	
        		on
	        	
	        	    algorithm
	        	
	        
       	</span>

        <h1 class="post-title">动态连通性问题</h1>

        <section class="post-content">
            <p>在一个图结构中，动态加入某条边后，希望快速判断两个节点是否联通。     </p>

<h4>解决方案:</h4>

<p>对于加边的union函数，使用 <code>Weighted Quick Union</code> (加权的快速合并算法)      </p>

<h5>主要思想：</h5>

<p>实用并查集的思想，把联通的集合搞成一颗树，如果节点同根则节点联通。<br>
关于【加权】，是为了防止树的高度过大，导致判断连通性的复杂度达到O(n)级别。     </p>

<h5>数据结构：</h5>

<p>数组，数组下标为每个节点的编号，数组内容为该节点的<code>父节点</code>编号。     </p>

<hr>

<h4>算法思路:</h4>

<h5>判断算法(isConnected()方法)</h5>

<p>判断两个节点的根节点是否相同。     </p>

<h5>加边算法思路：(union()方法)</h5>

<ol>
<li>判断A节点和B节点是否已经联通，若已经联通直接退出<br></li>
<li>如果没有联通，则开始合并她俩所在的联通集（也就是树）<br>

<ul>
<li>比较两棵树的权重，小树接到大树上去<br></li>
<li>方法是：把小树的<code>根节点</code>，挂到大树的<code>根节点</code>下面。（即把小树根节点的父节点设置为大树的根节点）<br></li>
</ul></li>
</ol>

<p>[注]这里封装了一个findRoot的算法，返回节点所在树的根节点的下标     </p>

<p>代码实现：    </p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="lineno"> 1</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">WeightedQuickUnionUF</span> <span class="o">{</span>     
<span class="lineno"> 2</span>     <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>    <span class="c1">// id[i] = parent of i     </span>
<span class="lineno"> 3</span>     <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sz</span><span class="o">;</span>    <span class="c1">// sz[i] = number of objects in subtree rooted at i     </span>
<span class="lineno"> 4</span>     <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>   <span class="c1">// number of components     </span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span>     <span class="cm">/**     </span>
<span class="lineno"> 7</span> <span class="cm">     * Initializes an empty union-find data structure with N isolated components 0 through N-1.     </span>
<span class="lineno"> 8</span> <span class="cm">     * @param N the number of objects     </span>
<span class="lineno"> 9</span> <span class="cm">     */</span>     
<span class="lineno">10</span>     <span class="kd">public</span> <span class="nf">WeightedQuickUnionUF</span><span class="o">(</span><span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>     
<span class="lineno">11</span>         <span class="n">count</span> <span class="o">=</span> <span class="n">N</span><span class="o">;</span>     
<span class="lineno">12</span>         <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>     
<span class="lineno">13</span>         <span class="n">sz</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>     
<span class="lineno">14</span>         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>     
<span class="lineno">15</span>             <span class="n">id</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>     
<span class="lineno">16</span>             <span class="n">sz</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>     
<span class="lineno">17</span>         <span class="o">}</span>     
<span class="lineno">18</span>     <span class="o">}</span>     
<span class="lineno">19</span> 
<span class="lineno">20</span> 
<span class="lineno">21</span>     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findRoot</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>     
<span class="lineno">22</span>         <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">])</span>     
<span class="lineno">23</span>             <span class="n">p</span> <span class="o">=</span> <span class="n">id</span><span class="o">[</span><span class="n">p</span><span class="o">];</span>     
<span class="lineno">24</span>         <span class="k">return</span> <span class="n">p</span><span class="o">;</span>     
<span class="lineno">25</span>     <span class="o">}</span>     
<span class="lineno">26</span> 
<span class="lineno">27</span>     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>     
<span class="lineno">28</span>         <span class="k">return</span> <span class="nf">findRoot</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">==</span> <span class="n">findRoot</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>     
<span class="lineno">29</span>     <span class="o">}</span>     
<span class="lineno">30</span> 
<span class="lineno">31</span>   
<span class="lineno">32</span>     <span class="cm">/**     </span>
<span class="lineno">33</span> <span class="cm">     * Merges the component containing site p with the component     </span>
<span class="lineno">34</span> <span class="cm">     * containing site q.     </span>
<span class="lineno">35</span> <span class="cm">     * @param p the integer representing one site     </span>
<span class="lineno">36</span> <span class="cm">     * @param q the integer representing the other site     </span>
<span class="lineno">37</span> <span class="cm">     * @throws java.lang.IndexOutOfBoundsException unless both 0 &lt;= p &lt; N and 0 &lt;= q &lt; N     </span>
<span class="lineno">38</span> <span class="cm">     */</span>     
<span class="lineno">39</span>     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>     
<span class="lineno">40</span>         <span class="kt">int</span> <span class="n">rootP</span> <span class="o">=</span> <span class="n">findRoot</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>     
<span class="lineno">41</span>         <span class="kt">int</span> <span class="n">rootQ</span> <span class="o">=</span> <span class="n">findRoot</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>     
<span class="lineno">42</span>         <span class="k">if</span> <span class="o">(</span><span class="n">rootP</span> <span class="o">==</span> <span class="n">rootQ</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>     
<span class="lineno">43</span> 
<span class="lineno">44</span>         <span class="c1">// make smaller root point to larger one     </span>
<span class="lineno">45</span>         <span class="k">if</span>   <span class="o">(</span><span class="n">sz</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="o">[</span><span class="n">rootQ</span><span class="o">])</span> <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootQ</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">rootP</span><span class="o">];</span> <span class="o">}</span>     
<span class="lineno">46</span>         <span class="k">else</span>                         <span class="o">{</span> <span class="n">id</span><span class="o">[</span><span class="n">rootQ</span><span class="o">]</span> <span class="o">=</span> <span class="n">rootP</span><span class="o">;</span> <span class="n">sz</span><span class="o">[</span><span class="n">rootP</span><span class="o">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="o">[</span><span class="n">rootQ</span><span class="o">];</span> <span class="o">}</span>     
<span class="lineno">47</span>         <span class="n">count</span><span class="o">--;</span>     
<span class="lineno">48</span>     <span class="o">}</span>     
<span class="lineno">49</span> 
<span class="lineno">50</span> 
<span class="lineno">51</span>     <span class="cm">/**     </span>
<span class="lineno">52</span> <span class="cm">     * Reads in a sequence of pairs of integers (between 0 and N-1) from standard input,      </span>
<span class="lineno">53</span> <span class="cm">     * where each integer represents some object;     </span>
<span class="lineno">54</span> <span class="cm">     * if the objects are in different components, merge the two components     </span>
<span class="lineno">55</span> <span class="cm">     * and print the pair to standard output.     </span>
<span class="lineno">56</span> <span class="cm">     */</span>     
<span class="lineno">57</span>     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>     
<span class="lineno">58</span>         <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>     
<span class="lineno">59</span>         <span class="n">WeightedQuickUnionUF</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">WeightedQuickUnionUF</span><span class="o">(</span><span class="n">N</span><span class="o">);</span>     
<span class="lineno">60</span>         <span class="k">while</span> <span class="o">(!</span><span class="n">StdIn</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>     
<span class="lineno">61</span>             <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>     
<span class="lineno">62</span>             <span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>     
<span class="lineno">63</span>             <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>     
<span class="lineno">64</span>             <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>     
<span class="lineno">65</span>             <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">q</span><span class="o">);</span>     
<span class="lineno">66</span>         <span class="o">}</span>     
<span class="lineno">67</span>         <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">count</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; components&quot;</span><span class="o">);</span>     
<span class="lineno">68</span>     <span class="o">}</span>     
<span class="lineno">69</span> 
<span class="lineno">70</span> <span class="o">}</span></code></pre></div>
     

        </section>

        

        <footer class="post-footer">
        	<!-- If we want to display author's name and bio -->
            
                <section class="author">
                	<header> <a href=""> <img class="profile" src="/assets/images/profile.png" alt="Author's profile picture"></a></header>
                	<article>
                		<!-- Author Name -->
                    	<h4> Rock Lu </h4>
                    	<!-- Author Bio -->
                    	<p> 
                    		<!-- Here goes the author description. You might want to place some links too in here -->
                    	    A newbie coder    <br>
                            Contact: &nbsp luleruler@gmail.com

                        </p>
                    </article>
                </section>                
            
        	
        </footer>

    </article>

</main>


    <footer class="site-footer">
        <a class="subscribe icon-feed" href="rss.xml"><span class="tooltip">Subscribe!</span></a>
        <div class="inner">
             <section class="copyright">All content copyright <a href="">Rock's personal notebook</a> &copy;  &bull; All rights reserved.</section>
             <section class="poweredby">Made with Jekyll using <a href="http://github.com/rosario/kasper">Kasper theme</a></section>
        </div>
    </footer>

    
    <script type="text/javascript" src="/assets/js/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->

</body>
</html>
