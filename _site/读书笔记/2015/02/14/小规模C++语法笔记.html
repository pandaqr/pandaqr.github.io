<!DOCTYPE html>
<html>
<head>   
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>Rock's personal notebook - Blogging something deserved</title>
    <meta name="description" content="Your New Jekyll Site, Blogging about stuffs" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="/assets/css/normalize.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />

    <!-- This is for syntax highlight -->
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css">
    <!-- Customisation  -->
    <link rel="stylesheet" type="text/css" href="/assets/css/main.css" />

</head>
<body class="home-template">

    
    <main class="content" role="main">

    <article class="post">
        <header class="post-header">
            <a id="blog-logo" href="http://rulerstorm.github.io">
                
                    <span class="blog-title">Rock's personal notebook</span>
                 
            </a>
        </header>
        
        <span class="post-meta">
        	<time datetime="2015-02-14">14 Feb 2015</time>
        	
        		on
	        	
	        	    读书笔记
	        	
	        
       	</span>

        <h1 class="post-title">小规模C++语法笔记</h1>

        <section class="post-content">
            <p>之前虽然有系统学过C++，但还是低估了<code>Primer</code>的事无巨细。在加上C++11的诸多变化，两三天根本看不完，还是不花太多时间复习语法了，先写起来吧~这里把这三天回顾的要点记录下来。     </p>

<h4>小Tips</h4>

<ol>
<li>无符号类型和有符号类型计算时，都化成无符号类型。所以切勿混用。<br></li>
<li>字符串字面值相邻，且中间仅有<code>空白字符</code>时，被编译成一个整体字符串常量<br></li>
<li>局部变量与全局变量重名时，在其生存期内覆盖全局变量，出了生存期消亡，全局变量在此期间不受影响。<br></li>
<li>常量（字面值）在编译期，全部替换成对应的值。<br></li>
</ol>

<h4>关于<code>=</code>符号</h4>

<ol>
<li>注意区分赋值和初始化，在变量定义时用<code>=</code>号为初始化<br></li>
<li>其他为赋值。赋值时，如果两者类型不同，先进行<code>隐式类型转化</code>。<br></li>
</ol>

<h4>定义和申明</h4>

<p>申明：用于给编译器产生符号表，可以多次申明<br>
定义 = 申明 + 申请内存空间 （不一定立刻分配）     </p>

<h4>再看<code>左值</code>和<code>右值</code></h4>

<p>左值：的是这个「变量」所占的<code>内存区域</code><br>
右值：这个「变量」所代表的<code>值</code><br>
[注]即使不能被赋值，也可以是左值哦。如const对象。     </p>

<h4>C++中的自增符号</h4>

<p>与C中略有不同：(C中两个都是右值)<br>
<code>++i</code>是<code>左值</code>，在表达式中参与计算的时i<code>本身</code><br>
<code>i++</code>是<code>右值</code>，参与计算的是i在增加前的<code>副本</code>     </p>

<hr>

<h4>关于别名</h4>

<p>除了<code>typedef</code>，c++11中增加了新的<code>using new_name = old_name</code>方式，却别不明。<br>
[注]对于别名的指针，在理解其类型时，请不要把别名替换成本来的样子以后再去解读，应该把别名看成一个整体类型。<br>
例如：     </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>     
<span class="k">const</span> <span class="n">pstring</span> <span class="n">var</span><span class="p">;</span>   <span class="c1">// var是指向char的常量指针（顶层const）     </span>
<span class="c1">//如果先做名称替换：const char * var;     </span>
<span class="c1">//则会把var误读成指向const char的变量指针（底层const）</span></code></pre></div>
      

<hr>

<h4>NULL和nullptr</h4>

<p>nullptr是c++的<code>关键字</code>，有自己的数据类型，NULL是宏定义常量     </p>

<h5>为何需要nullptr？请看例子：</h5>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">){}</span>     
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">){}</span>     

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>     
    <span class="n">f</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">// which function will be called?     </span>
<span class="p">}</span></code></pre></div>
        

<p>上面代码编译器表错，因为无法判断该调用哪个函数。有了nullptr后问题解决。     </p>

<hr>

<h4>顶层const和底层const</h4>

<p>主要用于描述指针或者引用。<br>
顶层const--<code>top-level const</code>--指针本身是常量<br>
底层const--<code>low-level const</code>--指针所指向的对象是const的<br>
[注]<br>
1. 顶层const经常在赋值或传参后丢失，而底层const是不允许丢失的。<br>
2. 普通对象的const都是顶层const     </p>

<hr>

<h4>auto和decltype</h4>

<p>用途：自动类型推断（实际应用？）<br>
谁来推断：编译器    </p>

<h5>「auto」:</h5>

<p>定义变量时，由定义时赋给它的<code>初始值</code>推断变量的类型。<br>
[例]<code>auto i = var1 + var2</code><br>
[注]忽略顶层const，保留底层const。如需保留顶层const，请<code>const auto</code>     </p>

<h5>「decltype」:</h5>

<p>auto在推断类型时，必须给他赋初始值。decltype则仅仅是得到表达式的数据类型。（不计算，也不根据表达式的值来推断）<br>
[例]<code>decltype(func()) i = 1</code> （比如func的返回类型为int）（注意不计算func）<br>
规则：<br>
1. 括号内是<code>变量</code>。则直接拷贝变量的类型（原样拷贝，不像auto忽略顶层const）<br>
2. 括号内是<code>表达式</code>，则要看表达式结果是一个<code>左值</code>和<code>右值</code>。<br>
    - 如果是左值：返回这个值的<code>引用</code>类型。<br>
    - 如果是右值：则直接拷贝这个值的类型。     </p>

<blockquote>
<p>[注]<br>
1. 不知道为啥要把左值搞成引用，有待研究<br>
2. 对于带括号的单个变量，编译器会解释为表达式，所以，<code>decltype((i))</code>这种两层括号的变量，一定会返回一个引用的i的类型。请小心！<br>
3. 为啥要有「类型推断」？好处在哪里？请研究！     </p>
</blockquote>

<hr>

<h4>范围for语句</h4>

<p>对于C++11新增的：<code>for(auto item : contaner)</code><br>
实际上处理为：     </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">contaner</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">contaner</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">){</span>     
    <span class="k">auto</span> <span class="n">item</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>     
    <span class="c1">//以下是原来的循环体     </span>
<span class="p">}</span></code></pre></div>
      

<p>所以，实质上还是依赖于<code>迭代器</code>--&gt;迭代器可能失效时不能用这种for！     </p>

<hr>

<h4>显示类型转化</h4>

<p>与C语言单一的强制转化不同，C++的类型转化细分为四种，分别完成旧式C强转的功能：     </p>

<h5><code>static_cast</code></h5>

<p>用途：普通的类型转化，可以调用class的构造函数<br>
[注]<br>
1. 不可转化底层的const。<br>
2. 比较安全，转化时会翻译二进制。    </p>

<h5><code>dynamic_cast</code></h5>

<p>用途：把「基类」指针<code>安全地</code>转化为「派生类」指针或引用。</p>

<h5><code>const_cast</code></h5>

<p>用途：专门用于转化「底层const」。<br>
一般情况下底层const是不允许丢失的，如果强制把底层const去掉，修改指向的常量的话，会发生不可预知的错误。（因为人家常量在编译的时候已经变成数字了。。。）<br>
那这东西能用在哪里呢？<br>
主要用在函数调用时的参数适配，先把它转成底层const，调用函数，然后再去掉。。。这样可以很方便地用一个写好的const版本函数，重载出一个非const版本的函数（强转，然后调用const版本）。     </p>

<h5><code>reinterpret_cast</code></h5>

<p>用途：正宗的强制转化。机器级的重新解释二进制。例如把int<em>强转char</em></p>

<hr>

<h4>调试帮助</h4>

<p>_     </p>

<h5>assert断言</h5>

<p><code>assert</code>不是函数，是「宏」。定义在<code>cassert</code>头文件中。<br>
[重要]assert可在编译时取消：<br>
在头文件中<code>#define NDEBUG</code>即可让assert失效。<br>
也可在编译时加入选项：<code>g++ -D NDEBUG xx.cpp</code>     </p>

<h5>预定义宏</h5>

<p>除了C语言中的<strong>LINE</strong>外，增加一个有用的<code>__func__</code>（注意小写！）     </p>

<hr>

<h4>「直接初始化」和「拷贝初始化」</h4>

<p>举例说明：     </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">ss</span> <span class="o">=</span> <span class="s">&quot;这是拷贝初始化&quot;</span>     
<span class="n">string</span> <span class="n">ss</span><span class="p">(</span><span class="s">&quot;这是直接初始化&quot;</span><span class="p">)</span>     
<span class="n">string</span> <span class="n">ss</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>  <span class="c1">//这也是直接初始化</span></code></pre></div>
      

<p>区别：<br>
直接初始化--直接调用相应类型的构造函数<br>
拷贝初始化--先把<code>=</code>号右边的内容用<code>构造函数</code>隐式转化成该类型，再调用<code>拷贝构造函数</code>     </p>

<blockquote>
<p>[注]函数传参的时候，是用「实参」拷贝初始化「形参」的。     </p>
</blockquote>

<hr>

<h4>重载与函数匹配</h4>

<p>_     </p>

<h5>为什么C++能重载而C不能？</h5>

<p>C在编译时的符号表仅有函数名，而C++在函数名的基础上，加上了参数。所以认为，名称相同、参数不同的函数是不同的。     </p>

<h5>重载规则</h5>

<ol>
<li>参数可以重载，返回值不能重载<br></li>
<li>参数不可以重载顶层const。 例子：<br></li>
</ol>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>   <span class="c1">//i在func作用域内为常量，只读     </span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>         <span class="c1">//非法，     </span>
                          <span class="c1">//因为对于int类型的实参，编译器不知道该调用谁     </span>
<span class="c1">//底层const重载是合法的。</span></code></pre></div>
      

<h5>函数匹配</h5>

<p>调用重载的函数时，具体调用哪一个，规则如下：<br>
1. 没有最佳匹配时，允许参数的隐式转化，但是越少越好<br>
2. 如果两个都有转化，必须有一个<code>完爆</code>另一个（至少有一项比你强，没有任何一项比你差）     </p>

<div class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">){}</span>       <span class="c1">//1     </span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">){}</span>       <span class="c1">//2     </span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">){}</span>    <span class="c1">//3     </span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>     
    <span class="n">func</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">);</span>         <span class="c1">//对于1，第一和第三个参数转化     </span>
                                    <span class="c1">//对于2，第二和第三个参数转化     </span>
                                    <span class="c1">//对于3，仅第三个转化。所以3完爆1和2，调用3     </span>
                                    <span class="c1">//如果没有3，则报错，1和2谁也不能完爆谁     </span>
<span class="p">}</span></code></pre></div>
      

<hr>

<h4>类</h4>

<ol>
<li>内容较多，只讲重点</li>
<li>不涉及大型OOP需要用到的继承、虚函数等内容。</li>
</ol>

<h5>类作用域</h5>

<p>对于private的成员，仅本类内部和friend能访问。</p>

<h5><code>this</code>指针</h5>

<p>在「对象」调用成员函数时，<code>隐式传递</code>指向「该对象地址」的this指针。
[注]所以，成员函数的参数列表，其实默认多一个指针。</p>

<h5>const成员函数</h5>

<p>因为this指针是隐式传递的，那么对于const对象，this指针的底层const谁来保护呢？答案是const成员函数，写在参数后面的const，实际上是表示传递的this指针是底层const的，即在这个函数中，不能对该对象进行修改。
[注]但是可以修改mutable的成员。</p>

<h5>构造函数</h5>

<ol>
<li>如果你不管，会默认生成一个无参的版本。</li>
<li>如果你写了，不管有没有参数，编译器就不会帮你默认生成了</li>
<li>此时如果还想要默认的，请<code>Class_init()=default</code>（C++11新功能）
[注]不能为const，不能private（想想就知道不行）</li>
</ol>

<h5>构造函数的初始值列表</h5>

<p>初始化时，仅按照类成员的书写顺序，初始化列表的顺序不管的。所以，最好把初始化列表的顺序写得和类成员顺序一致。</p>

<h5>禁止调用构造函数去隐式类型转换</h5>

<p>如果不想被系统自动调用这个构造函数，请<code>explicit</code></p>

        </section>

        

        <footer class="post-footer">
        	<!-- If we want to display author's name and bio -->
            
                <section class="author">
                	<header> <a href=""> <img class="profile" src="/assets/images/profile.png" alt="Author's profile picture"></a></header>
                	<article>
                		<!-- Author Name -->
                    	<h4> Rock Lu </h4>
                    	<!-- Author Bio -->
                    	<p> 
                    		<!-- Here goes the author description. You might want to place some links too in here -->
                    	    A newbie coder    <br>
                            Contact: &nbsp luleruler@gmail.com

                        </p>
                    </article>
                </section>                
            
        	
        </footer>

    </article>

</main>


    <footer class="site-footer">
        <a class="subscribe icon-feed" href="rss.xml"><span class="tooltip">Subscribe!</span></a>
        <div class="inner">
             <section class="copyright">All content copyright <a href="">Rock's personal notebook</a> &copy;  &bull; All rights reserved.</section>
             <section class="poweredby">Made with Jekyll using <a href="http://github.com/rosario/kasper">Kasper theme</a></section>
        </div>
    </footer>

    
    <script type="text/javascript" src="/assets/js/jquery-1.10.2.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Google Analytics Tracking code -->

</body>
</html>
