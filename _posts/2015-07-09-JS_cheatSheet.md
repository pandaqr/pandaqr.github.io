---     
layout: post     
title:  "JS_CheatSheet"     
date:   2015-07-09 06:01:00     
categories: JS     
---     
   
以下是犀牛书前几章的笔记。基本涵盖了js的主要语言特性，并没有包含高级特性。以后有需要再深入。     

#### 小细节     
1. js 区分大小写，而html不区分     
2. js中所有的数字都是IEEE754的`64位`浮点数。「注意」浮点数舍入。     
3. 数组下标是`32位`无符号整数。     

#### 未定义的变量     
未定义的变量看上去像全局变量，实际上不是，它被自动生成为全局对象的`属性`。     

#### 对于字符     
采用`UTF-16`编码，通常每个字符用16bit表示，超出16bit的不分，则用32个bit表示。对字符变量取`.length`时，每16bit为1。即通常一个字符的长度为1，如果该字符超出UTF-16的范围，则长度为2。     
「另外」js中可以采用`\u0008`这样的unicode编码直接表示某字符。     

#### 包装对象     
对于`字符串`、`数字`、`布尔值`三种「原始类型」，在调用其属性或方法时，解释器会调用`String()`、`Number()`、`Boolean()`构造函数，生成一个「临时」的包装对象，然后用这个对象进行属性或方法调用。作用于这个临时对象的操作并不对原来那个值产生影响，需小心。     


#### 偷懒的类型转化     
x + ‘’     =》 转字符串     
+x   =》 转数字     
!!x   =》  转布尔值     


##### 值得注意的类型转化     
字符串转布尔：非空串即true     
字符串转数字：有字母则NaN，空串为0     
Object转布尔：恒为true     
Object转数字：恒为NaN     


#### 对象到原始值的转化     
`toSting()`转为sting，`valueOf()`转为number     
「注」如果一个对象没有toString方法，或者这个方法无效（原封不动返回对象而不是原始值）。此时解释器会尝试调用valueOf方法，先转成数字，再转成字符串。对于valueOf也是这样，转不动的时候会去尝试调用toString。。。好无奈     

#### 作用域     
没有块级作用域，只有`函数作用域`。即在函数内无论何处定义都可用。     
「变量名提前」，即在同一个作用域内，后面定义的变量前面就能用了。但注意提前的只是`声明`，初始化仍然是在后面。     

#### 作用域链     
可以调用上一层函数作用域里面的对象。由链表一层一层向上找。     

「具体实现」：作用域链是对象的链表，每个节点代表一个函数作用域。变量的作用域由函数的`定义`位置决定，但是只有在在函数`执行`时，才会开始拓展作用域链。具体步骤是：创建一个对象，包含这个函数内定义的所有局部变量，然后把这个对象作为链表指向上一个节点（这是由函数的定义位置决定的）。     

再谈「闭包」：     

0. 我们为什么要用闭包？希望解决的问题是：再次调用函数时，希望能从上一次的状态继续。或者说，希望保存函数的`状态`。于是有了方法1:全局变量。缺点：乱，不好维护。于是有了方法2：把状态变量直接挂载到函数上，作为一个属性（函数也是对象）。缺点：缺乏私有的访问限制。于是我们终于有了方法3：闭包。所以闭包解决的问题，只不过是让这个状态变量私有化。`松本行弘`认为，闭包与Class都是把函数与变量封装起来，他们的关系就像一个硬币的正反面，只是实现方式不同罢了。     
1. 机理。js与c不同，函数的调用并不在`栈空间`，而是创建一个`临时对象`存放局部变量。如果没有其他变量引用这个对象，在函数执行完毕后该对象会被垃圾回收。而闭包就是把局部定义的函数返回出去，让外界引用持有，于是整个函数生成的临时对象都会存活下来。     
2. 要注意的有两点：1：由于每次函数执行都会生成一个临时对象，所以那些临时变量间互不干扰，分别处于同级别的`不同的`作用域链。2：要时刻注意闭包虽然把变量封闭在函数里面了，但是这些变量并没有固化静态快照。     
3. 现在看来，闭包在功能是为了封装隔离某些函数多次调用时需要保存的状态变量。其实在class机制完全的语言里，只要把那些变量设为private就可以实现，只是js的类机制比较弱，用作用域链实现隔离。     


#### 属性访问表达式     
要访问一个对象的属性，可以是点语法，也可以在方括号里面写属性的名称字符串。     
「注意」方括号里面无论是什么，先转字符串！所以即使是数组下标，也是先把数字转成字符串去查找的。     


#### 「相等」的判定     
1. `==`允许类型转化，`===`不允许类型转化     
2. 对象的比较，比较的是指针。     
3. 字符串的比较，比较的是unicode码，码不同，即使字符相同也不等     
4. `NaN`与任何值都不相等，它和自己也不等。     
5. 数字与其他类型比较均转化为数字再比较     

#### eval()函数     
eval函数把参数字符串作为代码来执行，并可调用eval位置的上下文。     
如果给eval函数取别名，调用别名函数时，则操作全局上下文（局部变量不可见）     


#### switch     
switch的行为类似于c语言。「注意」case的判定不做类型转化，即`===`。     

#### JS的对象     
js的`对象`就是`「字典」`。     
js的继承是对象的继承，而不是class的继承。     
对象的「prototype」就是`构造函数`的`prototype`属性     
对象的「class」就是「构造函数」`（有待验证）`     

「例子」一个数组[1, 2]，Array就是它的类，`Array.prototype`就是它的原型。对于数组的各种方法均定义在Array.prototype中。     

#### 属性的特性（property attribute）     
1. `writable`—可写。（可修改）     
2. `enumerable`—可枚举。     
3. `configurable`—可配置。（就是能否更改这些属性）     


#### 属性的检测     
1. `x.hasOwnProperty()`—检测自有属性     
2. `in`运算符—-检测包括继承的属性     
3. `x.propertyIsEnumerable()`—检测可枚举的`自有`属性     
「啥叫可枚举」用for-in遍历对象时，会遍历到的属性就是enumerable的     

#### delete运算符     
删除对象对属性的`引用`。通常可以删除某个属性，但是如果其子属性也被其他对象引用，并不会被立刻销毁。     
另外，delete不能销毁继承来的属性。     

`Object.Keys()`与`Object.getOwnPropertyNames()`的区别？     
第一个会追溯原型链，第二个不会。     


#### 关于「数组」值得注意的地方     
1. 直接量的语法中，最后一个逗号`,`是可以选的。[,]是空数组     
2. 数组的索引是32位整数。     
3. 数组与普通对象的区别？维护一个length，索引为`unsigned_int32_t`     
4. 「省略值」仍旧有key，而value是`undefined`。这不代表没有元素。     
5. for-in不会遍历到省略值的key。     

#### 关于「函数」值得注意的地方     
1. 调用函数时，解释器并不检查传入的参数。     
2. 函数也是`对象`，可以有属性，存点状态什么的。     

#### 函数的「arguments」属性     
1. 它是一个`类数组`（行为看上去像数组），下标访问得到实际传入的参数     
2. `arguments.length`代表传入的`实参`数量，`arguments.callee.length`代表函数定义时的`形参`数量。     
3. `callee`属性代表当前函数     
4. `caller`属性代表调用本函数的函数     
5. 「注意」callee和caller在`严格模式`下不可用。     
   









