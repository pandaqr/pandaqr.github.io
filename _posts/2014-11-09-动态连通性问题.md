---     
layout: post     
title:  "动态连通性问题"     
date:   2014-11-09 14:53:00     
categories: Algorithm     
---     

在一个图结构中，动态加入某条边后，希望快速判断两个节点是否联通。     


####解决方案:        
对于加边的union函数，使用 `Weighted Quick Union` (加权的快速合并算法)      
      
#####主要思想：         
实用并查集的思想，把联通的集合搞成一颗树，如果节点同根则节点联通。    
关于【加权】，是为了防止树的高度过大，导致判断连通性的复杂度达到O(n)级别。     

#####数据结构：       
数组，数组下标为每个节点的编号，数组内容为该节点的`父节点`编号。     

---     


####算法思路:     

#####判断算法(isConnected()方法)    
判断两个节点的根节点是否相同。     

#####加边算法思路：(union()方法)     
1. 判断A节点和B节点是否已经联通，若已经联通直接退出    
2. 如果没有联通，则开始合并她俩所在的联通集（也就是树）     
    - 比较两棵树的权重，小树接到大树上去     
    - 方法是：把小树的`根节点`，挂到大树的`根节点`下面。（即把小树根节点的父节点设置为大树的根节点）     

[注]这里封装了一个findRoot的算法，返回节点所在树的根节点的下标     

代码实现：    

{% highlight java linenos %}     
public class WeightedQuickUnionUF {     
    private int[] id;    // id[i] = parent of i     
    private int[] sz;    // sz[i] = number of objects in subtree rooted at i     
    private int count;   // number of components     

    /**     
     * Initializes an empty union-find data structure with N isolated components 0 through N-1.     
     * @param N the number of objects     
     */     
    public WeightedQuickUnionUF(int N) {     
        count = N;     
        id = new int[N];     
        sz = new int[N];     
        for (int i = 0; i < N; i++) {     
            id[i] = i;     
            sz[i] = 1;     
        }     
    }     


    public int findRoot(int p) {     
        while (p != id[p])     
            p = id[p];     
        return p;     
    }     

    public boolean isConnected(int p, int q) {     
        return findRoot(p) == findRoot(q);     
    }     

  
    /**     
     * Merges the component containing site p with the component     
     * containing site q.     
     * @param p the integer representing one site     
     * @param q the integer representing the other site     
     * @throws java.lang.IndexOutOfBoundsException unless both 0 <= p < N and 0 <= q < N     
     */     
    public void union(int p, int q) {     
        int rootP = findRoot(p);     
        int rootQ = findRoot(q);     
        if (rootP == rootQ) return;     

        // make smaller root point to larger one     
        if   (sz[rootP] < sz[rootQ]) { id[rootP] = rootQ; sz[rootQ] += sz[rootP]; }     
        else                         { id[rootQ] = rootP; sz[rootP] += sz[rootQ]; }     
        count--;     
    }     


    /**     
     * Reads in a sequence of pairs of integers (between 0 and N-1) from standard input,      
     * where each integer represents some object;     
     * if the objects are in different components, merge the two components     
     * and print the pair to standard output.     
     */     
    public static void main(String[] args) {     
        int N = StdIn.readInt();     
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N);     
        while (!StdIn.isEmpty()) {     
            int p = StdIn.readInt();     
            int q = StdIn.readInt();     
            if (uf.connected(p, q)) continue;     
            uf.union(p, q);     
            StdOut.println(p + " " + q);     
        }     
        StdOut.println(uf.count() + " components");     
    }     

}     

{% endhighlight %}     


