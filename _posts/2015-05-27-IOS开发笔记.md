---     
layout: post     
title:  "IOS开发笔记"     
date:   2015-05-27 16:01:00     
categories: IOS     
---     

IOS开发已经搞了两个月，积累了一些经验。详实记录，以供查阅。     

#### 调用OC的代码     
1. 需要建立一个`bridging-header.h`（本来好像会自动建立，现在需要手动建立了，名字无所谓）     
2. 在项目的`Build Settings`里面搜索swift，可以看到`Swift Compiler - Code Generation`大栏目，里面有`Objective-C Bridging Header`，把刚刚建立的头文件名字放进去就ok     
3. 然后，所有的oc头文件只要包含在这个桥文件里面，就自动在所有的swift文件里面可以使用了。     

---     

#### 如何创建一个View     
总体来说，如果这个View只管展示，不需要交互，可以直接创建一个裸的UIView。否则就创建一个UIViewController，会自带一个View。     

##### 方法一：通过storyBoard     

1. 有入口箭头的Controller会默认加载，如果找不到箭头了，请在controller属性里面找`Is Initial View Controller`把它勾上     
2. 对于segue指向的controller也是会自动加载     
3. 对于无法用segue连线的单独controller也可以放在storyboard中，此时先通过代码加载storyboard，然后通过唯一的`Storyboard ID`加载这个controller。     
示例代码：     

{% highlight swift %}     
let storyBoard = UIStoryboard(name: "Main", bundle: nil)    //先加载storyboard对象     
let chat = storyBoard.instantiateViewControllerWithIdentifier("inquiry") as! InquiryChatTableViewController    //再加载controller     
{% endhighlight %}     

##### 方法二：通过xib     
类似于从storyBoard，优点是多个view可以放在单独的文件里，归类。     
示例代码：     
{% highlight swift %}     
let nib = UINib(nibName: "TabBarView", bundle: nil)  //记得设置xib控件里面的class     
let newTabBar = nib.instantiateWithOwner(nil, options: nil)[0] as! MyTabBar  //注意实例化后返回的是数组     
{% endhighlight %}     

##### 方法三：通过代码new     
我碰到大概有这几种情况需要自己new     
1. 界面布局需要动态计算     
2. 需要一次性循环生成多个view     
3. 布局太简单没有什么子控件     


---     



#### 自定义控件的若干经验     

1. 基本思路是创建一个新类继承自默认类，然后对需要改动的方法进行override。     
2. 自定义的view如果需要交互，一般设置一个委托delegate属性，配套一个协议protocol定义好调用的函数，然后把外部的controller设置为它的委托，让view持有引用（weak）。事件发生时，view通过调用委托在协议中定义好的方法把事件传递给外部的controller。     
3. 自定义控件如果布局复杂，通常会搞一个xib，把控件的class设置为自定义的view。     
4. 从xib连线到view的`@IBOutlet`什么时候生效？ 这个需要详细查询view的生命周期，总之记住，在init()里面它们还为被设置，此时这些@IBOutlet的属性还均是nil。一个比较合适的方法是用swift的新功能`didSet`，在didset里面对这些属性进行配置。     
5. 对于需要用代码创建的子控件，可以放在init函数里面。此时处理事件就要`addTarget`     
6. 如果你的控件看不见……检查下以下方面：1，frame，2，是否加入主view的subView，3，alpha     
7. 当控件的frame变化时，会调用`layoutSubviews`，所以在这里面设置subView的frame最合适。     

---     

#### 关于启动页图片     
1. 图片命名为：`Default@2x.png`和`Default-568h@2x.png`放入项目     
2. 把[项目设置]中，`launch screen file`设置为`空`即可自动调用     

---     

#### UIButton专题     
_     
##### 各种属性设置     

{% highlight swift %}     
let btn = UIButton()     
btn.frame = CGRectMake(12, 12, 12, 12)     
self.view.addSubview(btn)     

//这些圆角的设定也适合于UIView     
btn.layer.cornerRadius = 4     
btn.layer.borderColor = mixiColor.mainCoffie.CGColor     
btn.layer.borderWidth = 0.5     
btn.layer.masksToBounds = true  //如果里面的子view多出来，就切掉     

//文字相关     
btn.setTitle(‘title', forState: UIControlState.Normal)     
btn.titleLabel?.font = UIFont.systemFontOfSize(12)     
btn.setTitleColor(mixiColor.mainCoffie, forState: UIControlState.Normal)     
btn.setTitleColor(mixiColor.mainCoffie, forState: UIControlState.Highlighted)     
btn.setTitleColor(UIColor.whiteColor(), forState: UIControlState.Selected)     

//背景颜色     
btn.setBackgroundImage(buttonImage, forState: UIControlState.Selected)     
btn.backgroundColor = mixiColor.mainCoffie     

//事件     
btn.addTarget(self, action:Selector("distrectBtnPressed:"), forControlEvents: UIControlEvents.TouchUpInside)     
{% endhighlight %}     
##### 按钮中图片和文字的位置怎么调？     
调整对齐方式：属性->Control->Alignment     
调整padding：属性->Button栏最下面->Edge选文字还是图片->Inset     
想图片在上文字在下：重写layoutSubviews方法。     

##### 如何让按钮按下去的时候不变色     
`btn.adjustsImageWhenHighlighted = false`     

##### 如何让按钮不能点     
`btn.userInterractionEnabled = false`     

---     

#### 素材图片的拉伸     
{% highlight swift %}       
extension UIImage{      
    class func resizabelImage(#name :String) ->UIImage?{     
        if let normalImage = UIImage(named: name){     
            let w = CGFloat(normalImage.size.width * 0.5)     
            let h = CGFloat(normalImage.size.width * 0.5)     
            return normalImage.resizableImageWithCapInsets(UIEdgeInsets(top: h, left: w, bottom: h, right: w))     
        }else{     
            return nil     
        }     
    }     
}     
{% endhighlight %}       


---     

#### 控制键盘     
_     

##### 关闭键盘     
`self.view.endEditing(true)`     

##### 触摸任意区域关闭键盘     

{% highlight swift %}     
var tapGestureRecognizer:UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: "keyboardHide")     

//为啥要加下面这行？答：不加的话里面的view的按钮会点不动。    
//参考：http://blog.csdn.net/kylinbl/article/details/9139473         
tapGestureRecognizer.cancelsTouchesInView = false;     
self.view.addGestureRecognizer(tapGestureRecognizer)     
{% endhighlight %}     

##### 监听键盘弹出事件     

{% highlight swift %}     
//这里是viewDidLoad里面     
NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector("keyboardWillChangeFrame"), name: "UIKeyboardWillChangeFrameNotification", object: nil)     


//这里是controller的class里面     
//弹出键盘时同时向上滚动view     
func keyboardWillChangeFrame(note :NSNotification){     
    var shift :CGFloat = 0     
    let userInfo = note.userInfo!     
    let keyboardFrame = userInfo[UIKeyboardFrameEndUserInfoKey]?.CGRectValue()     
    let transformY = keyboardFrame!.origin.y - self.view.frame.size.height     
    let duration = userInfo[UIKeyboardAnimationDurationUserInfoKey] as! Double     
    UIView.animateWithDuration(duration, animations: {     
        self.view.transform = CGAffineTransformMakeTranslation(0, transformY + shift)     
    });     
}     


//这里是controller的class里面     
//记得给controller写deinit，移除消息通知监听(必须)     
deinit {     
    NSNotificationCenter.defaultCenter().removeObserver(self);     
}     
{% endhighlight %}     

##### 呼出键盘     
`textField对象.becomeFirstResponder()`     


---     

#### 界面跳转     

在segue的prepare中不要直接去更新目标页面控件，而是把数据传给它的module，因为此时outlet还没有设置。然后在viewdidload中，用更新好的module来设置UI。     

往回跳     
self.navigationController?.popToRootViewControllerAnimated(true)     
self.navigationController?.popViewControllerAnimated(true)     

数据怎么回传？     
前面那个controller成为后面那个的代理（搞个协议），让后面那个持有前面那个的指针，然后就可以传参数调用前面那个controller的函数了     

---     

#### UITabbarController的自定义经验     

1. 重写viewWillAppear()，在里面直接self.tabBar.removeFromSuperview()。     
2. 把自定义的tabBar放到原来tabBar的位置（直接copy它的frame）     
3. 对于点击事件，UITabbarController作为自定义tabbar的委托，调用`self.selectedIndex = 下标数字`即可切换子controller     
4. 添加子controller的方法：`self.addChildViewController(子controller)`     


---     


#### UINavigationController的配置经验     
这个导航条蛮搞的，UINavigationController不但提供view的容器，还提供bar的容器。     

##### 哪些是由UINavigationController管的     
主要是格式类的配置，大概是希望一次性设置不用每个子controller再设置     
1. bar的`背景染色`(navi.navigationBar.`barTintColor`)     
2. bar上title的`文字属性`titleTextAttributes。包括颜色、字体、阴影等。     
3. bar上的`item染色`tintColor     
4. bar的特性，比如`navi.hidesBarsOnSwipe = true`，向上滑动时自动收起bar     

##### 哪些是由子controller管的配置     
内容性的配置，主要由一个navigationItem存储这些内容。（相当于一个module）     
1. 左边和右边的barItem（self.navigationItem.leftBarButtonItem）     
2. bar上面的title文字内容（self.navigationItem.title）     
「注」`self.navigationController`得到的就是上面那个UINavigationController     

##### 如何干掉默认的返回键文字     
左上角默认会把上一个controller的title写在那里，处理起来很不方便。有一个很机智的做法：重写上一个controller的`viewWillAppear`和`viewWillDisappear`，将要出现的时候加上title，将要消失的时候就把title设置为空。这样，push到下一个controller的时候返回键那里显示就是空拉~     

##### 如何设置barItem的位置？     
`self.navigationItem.leftBarButtonItem?.imageInsets = UIEdgeInsets(...)`     

##### 如何截获controller的pop？     
重写`popViewControllerAnimated(...)`方法，可以在pop前自定义操作，甚至可以指定pop至的controller。     


---     

#### UITableViewController的配置经验     
这个contorller强制你整个view都是tableview，不能加点别的东西，比较死，一般不用。通常是在一个默认的UIViewController里面拖一个tableView进去，设置一下delegation和dataSource。     

##### 为什么看不到cell？     
记得写这俩函数：     
{% highlight swift %}     
func numberOfSectionsInTableView(...){     
    return 1            //返回table的组数     
}     

func tableView(..., numberOfRowsInSection ...){     
    return 10           //返回table的行数，告诉controller每组一共几行     
}     

func tableView(..., cellForRowAtIndexPath ...){     
    let cell = tableView.dequeueReusableCellWithIdentifier("DaRenCell", forIndexPath: indexPath) as! DaRenTableViewCell    //DaRenCell是Prototype cell的id     
    return cell         //返回一个cell对象，告诉controller每一行显示啥     
}     
{% endhighlight %}     

##### 自动调整的row height     
如果cell里面的控件全都使用autoLayout，则可以让系统自己自动调整行高。在controller中做一下配置即可：     
{% highlight swift %}     
tableView.estimatedRowHeight = tableView.rowHeight     
tableView.rowHeight = UITableViewAutomaticDimension     
{% endhighlight %}     

##### 数据重载     
{% highlight swift %}     
//重载整个table     
self.tableView.reloadData()     
//重载单个cell并带动画     
self.tableView.reloadRowsAtIndexPaths([NSIndexPath(forRow: rowNmuber, inSection: 0)] , withRowAnimation: UITableViewRowAnimation.Automatic)     
{% endhighlight %}     

##### 滚动到指定的位置     
没仔细研究，总觉的这个方法有时有行有时候不行：     
{% highlight swift %}     
self.tableView.scrollToRowAtIndexPath(NSIndexPath(forRow: self.chatData.data.count-1, inSection: 0), atScrollPosition: UITableViewScrollPosition.Bottom, animated: true)     
{% endhighlight %}     

##### 滚动的检测     
tableView继承自scrollView，所以会调用`scrollViewDidScroll()`方法     

{% highlight swift %}     
//这段让上面的bar在tableview向上滚动时自动收起来     
@IBOutlet weak var mainSearchBar: UIView!     
var lastOffSet :CGFloat = 0     
var accumulate :CGFloat = 0  //累计判断正负，以防变化太快     

//监听tableview的滑动     
func scrollViewDidScroll(scrollView: UIScrollView) {     
    accumulate += scrollView.contentOffset.y - lastOffSet   //累计混动的距离，向上增加，向下减少     
    if(accumulate > 150){           //150的阈值比较合适     
        accumulate = 0     
        //这里代码让bar向上滑动，以隐藏     
    }else if(accumulate < -10){      //恢复的阈值设置的较低     
        accumulate = 0     
        //这里代码让bar恢复     
    }     
    lastOffSet = scrollView.contentOffset.y     
}     

{% endhighlight %}     

---     


#### 动画     
动画有两个比较常用，一个带结束后步骤，一个不带。     
「注意」同一个线程里，虽然你可以不等前面那个结束就开始下一个动画，但并不会并发。     
{% highlight swift %}     
UIView.animateWithDuration(0.1, animations: {[unowned self] in     
self.bookDateView.alpha = 0     //满满变透明     
}, completion: {     
if $0{      //这个$0是匿名函数必须的，代表动画是否成功     
MBProgressHUD.showHUDAddedTo(self.view, animated: true)     
}     
})     

//这个简单版本不带completion     
UIView.animateWithDuration(0.3, animations: {[unowned self] in     
self.bookSucceedView.alpha = 1     
})     

//注意这里[unowned self] 意思是闭包中不要捕获self，以防循环引用     
{% endhighlight %}     


---     

#### 多线程     
并没有深入研究，保存了一点有用的代码：     
{% highlight swift %}     
let qos = Int( QOS_CLASS_USER_INTERACTIVE.value)     
let queue = dispatch_get_global_queue(qos, 0)     
dispatch_async(queue) {     
    sleep(2)     
    //do something     
    dispatch_async(dispatch_get_main_queue()) {   //UI相关的动作必须切换到主线程     
        self.tableView.reloadData()     
    }     
}     
{% endhighlight %}     


---     


#### 折纸效果的侧滑栏实现     
滑动时侧边栏跟着移动并带渐变阴影，滑动时根据力度决定是否划开。     
这段代码我记得写了整整一天，调了无数bug，做到了较好的体验。     
并没有办法重现当时的神勇，直接保留代码。。。     
{% highlight swift %}     
//     
//  SlideViewController.swift     
//     
//  Created by LuRock on 15/3/22.     
//  Copyright (c) 2015年 LuRock. All rights reserved.     
//     

import UIKit     

//侧滑栏的宽度比例     
let SLIDERATE :CGFloat = 0.6     

protocol leftBarButtunDelegate :class{      //class关键字可以让这个协议使用weak指针，原因待查     
    func leftBarButtunClicked()     
}     


class SlideViewController: UIViewController, leftBarButtunDelegate, SlideBarViewDelegate {     
    
    private var slideBar :SlideBarViewController!     
    
    //存放所有可以被侧滑拦切换出来的viewcontroller。字典，key是view的名字，如“个人中心”     
    private var mainviewController = [String:UIViewController]()     
    //标记活动的controller     
    var activeMainViewControler :UIViewController!     
    
    
    //用来记录侧滑手势的上一个偏移值     
    private var lastX :CGFloat = 0     
    
    override func viewDidLoad() {     
        super.viewDidLoad()     
        
        //这里从storyboard读取并实例化侧边栏     
        let storyboard = UIStoryboard(name: "Main", bundle: nil)     
        self.slideBar = storyboard.instantiateViewControllerWithIdentifier("SlideBar") as! SlideBarViewController     
        self.slideBar.delegate = self     
        
        //设置侧边栏的frame     
        self.slideBar.view.frame = CGRect(x: -self.view.frame.width * SLIDERATE * 0.25, y: 0, width: self.view.frame.width * SLIDERATE, height: self.view.frame.height)     
        
        //先加到数组里面的view会在下面     
        self.addChildViewController(slideBar)     
        self.view.addSubview(slideBar.view)     
        self.view.sendSubviewToBack(slideBar.view)   //这句可以把某个view弄到最底下     
        
        //实例化子controller，设置它们的delegation，放置到mainviewController字典里     
        setUpMainViewController()     
        
    }//viewDidLoad     
    
    
    //这是个proxy，是为了统一化侧滑栏的阴影和移动     
    var slideBarTransform :CGAffineTransform = CGAffineTransformIdentity{     
        didSet{     
            self.slideBar.view.transform = slideBarTransform     
            self.slideBar.shadow.alpha = 1 - slideBarTransform.tx / (self.slideBar.view.frame.width * SLIDERATE * 0.5)     
        }     
    }     
    
    
    //translation不是翻译的意思，意思是“移动量”     
    func didDrag(pan:UIPanGestureRecognizer){     
        
        let point = pan.translationInView(pan.view!)     
        let slideBarWidth = self.slideBar.view.frame.width     
        let duration = 0.25     
        if let viewFrameMinX = pan.view?.frame.minX{     
            if (pan.state == UIGestureRecognizerState.Changed){     
                //这里记录上次的位置，以确定拖拽方向     
                self.lastX = viewFrameMinX     
            }     
            
            // 结束拖拽     
            if (pan.state == UIGestureRecognizerState.Cancelled || pan.state == UIGestureRecognizerState.Ended) {     
                if(viewFrameMinX > self.lastX){ //如果向右拖     
                    if (viewFrameMinX >= slideBarWidth * 0.2) { // 往右边至少走动了五分之一     
                        UIView.animateWithDuration(duration, animations: {     
                            pan.view!.transform = CGAffineTransformMakeTranslation(slideBarWidth, 0)     
                            self.slideBarTransform = CGAffineTransformMakeTranslation(slideBarWidth * SLIDERATE * 0.5, 0)     
                            
                        })     
                        
                    } else{ // 走动距离的没有达到四分之一     
                        UIView.animateWithDuration(duration, animations: {     
                            pan.view!.transform = CGAffineTransformIdentity   //这个参数需要理解，能复原位置     
                            self.slideBarTransform = CGAffineTransformIdentity     
                            
                        })     
                    }     
                }else{     
                    if (viewFrameMinX <= slideBarWidth * 0.8) { // 往左边至少走动了五分之一     
                        UIView.animateWithDuration(duration, animations: {     
                            pan.view!.transform = CGAffineTransformIdentity     
                            self.slideBarTransform = CGAffineTransformIdentity     
                        })     
                        
                    } else{     
                        UIView.animateWithDuration(duration, animations: {     
                            pan.view!.transform = CGAffineTransformMakeTranslation(slideBarWidth, 0)     
                            self.slideBarTransform = CGAffineTransformMakeTranslation(slideBarWidth * SLIDERATE * 0.5, 0)     
                            
                        })     
                    }     
                }     
            } else { // begin和changed都会进来     
                pan.view!.transform = CGAffineTransformTranslate(pan.view!.transform, point.x, 0)     
                slideBarTransform = CGAffineTransformTranslate(self.slideBar.view.transform, point.x * SLIDERATE * 0.5, 0)     
                pan.setTranslation(CGPointZero, inView: pan.view!)     
                if (pan.view!.frame.minX >= slideBarWidth) {     
                    pan.view!.transform = CGAffineTransformMakeTranslation(slideBarWidth, 0)     
                    slideBarTransform = CGAffineTransformMakeTranslation(slideBarWidth * SLIDERATE * 0.5, 0)     
                    
                } else if (pan.view!.frame.minX <= 0) {     
                    pan.view!.transform = CGAffineTransformIdentity     
                    slideBarTransform = CGAffineTransformIdentity     
                }     
            }     
        }     
    }     
    
    
    //代理方法，监听左上角点击     
    func leftBarButtunClicked(){     
        self.view.endEditing(true)     
        if(self.activeMainViewControler.view.frame.minX == 0){     
            UIView.animateWithDuration(0.4, animations: {     
                self.activeMainViewControler.view.transform = CGAffineTransformMakeTranslation(self.slideBar.view.frame.width, 0)     
                self.slideBarTransform = CGAffineTransformMakeTranslation(self.slideBar.view.frame.width * SLIDERATE * 0.5, 0)     
                
            })     
        }else{     
            UIView.animateWithDuration(0.4, animations: {     
                self.activeMainViewControler.view.transform = CGAffineTransformIdentity     
                self.slideBarTransform = CGAffineTransformIdentity     
            })     
        }     
    }     
    
    //代理方法，监听左边bar的点击，切换主view     
    func changeMainViewToTarget(targetView: String?) {     
        
        let gesture = UIPanGestureRecognizer(target: self, action: Selector("didDrag:"))     
        
        if let acticeView = self.activeMainViewControler?.view{   //有旧view     
            
            //如果点击已经活动的view，那就不要切换了     
            if self.activeMainViewControler! == mainviewController[targetView!]!{     
                return     
            }     
            
            leftBarButtunClicked()     
            
            //记录目前view的位置，等下交给新view     
            //          let originTransform = acticeView.frame   //如果这里用frame，则后面手势计算transform的时候会有严重bug     
            let originTransform = acticeView.transform     
            
            UIView.animateWithDuration(0.4, animations: { [unowned self] in     
                acticeView.transform = CGAffineTransformMakeTranslation(self.view.frame.width, 0)     
                }, completion: {     
                    if $0{     
                        //重要问题：手势识别器不能同时被多个view注册，否则只认最后一个view的手势     
                        //解除手势     
                        acticeView.removeGestureRecognizer(gesture)     
                        //去除view     
                        acticeView.removeFromSuperview()     
                    }     
            })     
            //这里开始加新view     
            if let target = targetView{     
                if let targetController = mainviewController[target]{     
                    self.view.addSubview(targetController.view)     
                    
                    //加入手势     
                    targetController.view.addGestureRecognizer(gesture)     
                    //一开始从最右边出现     
                    targetController.view.transform = CGAffineTransformMakeTranslation(self.view.frame.width, 0)     
                    //然后移到原来的位置     
                    UIView.animateWithDuration(0.4, animations: { [unowned self] in     
                        targetController.view.transform = originTransform     
                        })     
                    
                    self.activeMainViewControler = targetController     
                }     
            }     
            //没有旧view，就是第一次启动     
        }else{     
            if let target = targetView{     
                if let targetController = mainviewController[target]{     
                    self.view.addSubview(targetController.view)     
                    //加入手势     
                    targetController.view.addGestureRecognizer(gesture)     
                    self.activeMainViewControler = targetController     
                }     
            }     
        }     
    }     
    
    //4月20日新增，侧滑栏底下碰到可以收回去，体验更友好     
    func gestureBtnclicked(){     
        leftBarButtunClicked()     
    }     
    
    
    
    //可以改进的地方：并未检测用户滑动速度     
}     
{% endhighlight %}     


---     

#### 手机号码的鉴定     
{% highlight swift %}     
func isTelNumber(num:String)->Bool     
{     
    var mobile = "^1(3[0-9]|5[0-35-9]|8[025-9])\\d{8}$"     
    var  CM = "^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d{7}$"     
    var  CU = "^1(3[0-2]|5[256]|8[56])\\d{8}$"     
    var  CT = "^1((33|53|8[09])[0-9]|349)\\d{7}$"     
    var regextestmobile = NSPredicate(format: "SELF MATCHES %@",mobile)     
    var regextestcm = NSPredicate(format: "SELF MATCHES %@",CM )     
    var regextestcu = NSPredicate(format: "SELF MATCHES %@" ,CU)     
    var regextestct = NSPredicate(format: "SELF MATCHES %@" ,CT)     
    if ((regextestmobile.evaluateWithObject(num) == true)     
        || (regextestcm.evaluateWithObject(num)  == true)     
        || (regextestct.evaluateWithObject(num) == true)     
        || (regextestcu.evaluateWithObject(num) == true))     
    {     
        return true     
    }     
    else     
    {     
        return false     
    }     
}     
{% endhighlight %}     



---     

#### 遗留的问题     

在viewdidload里面实例化另一个controller，然后把这个controller里面的一个IBoutlet的view加到主controller的view里面，此时这个子controller的所有IBoutlet都是nil。然而把这个子controller直接的view直接加到主view里面却没问题，操蛋！     



 // MARK: - Table view data source     
insertSubview 和 addSubview 的区别？     
tableview里面的定位，图片怎么缩小恢复到那个位置     

self.addChildViewController(mainPageViewController)  //这个好像只有在tabbarController里面有用？self.selectedIndex = index可以切换到相应的childView     


//这个可以把主view编程scrollview？     
    override func loadView() {     
        super.loadView()     
        var scrollView:UIScrollView = UIScrollView(frame:super.view.frame)     
        self.view = scrollView     
    }     






