---     
layout: post     
title:  "Linux常用命令"     
date:   2015-01-26 04:37:10     
categories: Linux     
---     


#### xargs命令     
xargs代表construct argument lists and invoke utility     
[用途：]     
1. 有些命令的输入必须是命令行（如果可以是stdin，那可以用管道），用xargs可以把stdin的输入转化为命令行参数，加在目标命令后面     
2. 参数太长时，xargs会把参数分批次传送给目标命令     

［常用格式：］     
`参数源命令 | xargs 目标命令`     

［例子：］     
`ls -a | xargs cat`   —  这个相当于`cat ./*`，输出文件夹下每个文件的内容     
注意不同于`ls -a | cat`，这样只会输出ls -a的内容，而没有每个文件的内容     

---     

#### grep命令     
grep代表globally search a regular expression and print，用于全局正则搜索     
［常用格式：］     
`grep 参数 “your_pattern” target_path`     

［注意］     
1. 默认输出为stdout     
2. 匹配单元为行，所以不能跨行匹配     
3. 默认会输出匹配成功的整行     
4. 需要高级正则表达式时，请用`egrep`！     

［重要参数］     
`-l` 只输出匹配成功的文件名     
`-i` 忽略大小写     
`-v` 反向匹配，即输出不匹配的行     
`-n` 输出时包含行号     
`-r` 递归子文件夹     

---     

#### sed 命令     
sed代表stream editor，常用于文本替换。     
［常用格式：］     
`sed ’s/正则模式/替换内容/g’ target.txt`     
注释：     
1. `s`代表替换     
2. `g`代表`对所有的匹配全部替换`，不加g代表只替换`第一个匹配`     
3. `g`可以换成`d`，表示`删除`含有匹配的该行     

［注意］：     
1. 默认输出为标准输出，所以上面这个命令只会把替换结果打印到屏幕上。如果需要`直接替换`文本内容（危险！），需要`-i备份后缀`，     
例如：     
`sed  -i.bak ’s/正则模式/替换内容/g’ target.txt`  — 备份文件为：原文件.bak     
`sed  -i.ss ’s/正则模式/替换内容/g’ target.txt`  — 备份文件为：原文件.ss     
2. 正则匹配时，先回把文本按照行分裂开来，和grep相同     
3. 正则模式中，［小括号()］和［花括号{}］需要加`转义字符\`     
4. 有些老版本的sed默认不开启正则，需要`-e`     
5. 警告：此命令博大精深，man文档极其复杂，暂无需深入。     

［重要用法］     
`grep old_pattern -rl target_dir | xargs sed -i.bak 's/old_pattern/new_pattern/g'`     
搜索该文件夹内 所有含有模式的文件，用sed进行替换。     
注意xargs是必须的     

`sed -i.bakup.md 's/\([^ ].\{0,3\}$\)/\1     /g' *.md`     
对当前文件夹下的md文件操作，对于行尾空格少于四个的行，给他加四个空格。（写博客用的）     
注释：匹配模式为`[^ ].{0,3}`，即`最后四个字符里面有[非空格]`。后面有个`\1`反向引用，所以给前面加了小括号。     
感觉还可以优化。     

---

#### awk 命令     
awk不是谁的缩写，而是三个发明者的名字缩写。。。     
[用途]     
awk的主要用于格式化文本（有固定分隔符）的文本处理。与sed相比，擅长对文本分列处理（csv？）。awk是一门编程语言，也是复杂的不行，先从简单入手。     

[基本思想]     
awk和grep一样，对于文件，以`行`为单位依次处理文本，然后会对行「按照分隔符」进行分列，然后用`$1`表示`第1列`，`$2`表示`第2列`，注意`$0`表示`整行`。     

[常用格式：]     
`awk '/pattern/ {command1; command2; ...}' input_file`     
注释：     
1. `/pattern/` 表示「匹配这个模式的行」才会执行命令     
2. `command`表示命令，如：`print $1` 打印每行第一列     
3. `input_file` 可以没有，可以是从管道输入     

［重要参数］      
`-F` -- 指定分列的「分隔符」（默认是`空格`或`Tab`）     
`BEGIN{command}` -- 可以指定在`开始前`执行命令     
`END{command}` -- 指定在对所有行操作`结束后`执行命令     
完整格式：     
`awk -F'xx' 'BEGIN{command} /pattern/ {command1; command2; ...} END{command}'`     

例子：     
`printf '1 \n 2 \n 3' | awk '/[0-9]/ { sum += $1} END {print sum}'`     
`printf '1:2:3' | awk -F':' '{print $2}'`      
`printf '1:2:3' | awk 'BEGIN{RS=":"} {print}'`   //把`:`作为记录分隔符（分行），默认是`\n`，现在手动指定为`:`。     

综合一下：     
`printf '1:2:3' | awk 'BEGIN{RS=":"; sum=10} {sum += $1} END{print sum}'`     


