---     
layout: post     
title:  "重学「计算机网络」（2）"     
date:   2015-01-27 00:08:00     
categories: 基础课     
---     

重学计算机网络，主要是为了科普一下『网络常识』。所以在笔记内容上，我只记录我目前不知道的知识。也就是说，例如「分组交换」、「存储转发」这种我就忽略了。     

---

#### Internet 接入方式     
<table border="1px">     
	<thead bgcolor="#EAEAEA">     
		<th>名称</th><th>理论速度极限</th><th>承载方式</th><th>距离极限</th>     
	</thead>     
	<tbody>     
		<tr><td>DSL</td><td>24Mbps</td> <td>电话线多余带宽</td> <td>15km</td></tr>     
		<tr bgcolor="#EAEAEA"><td>电缆</td><td>42.8Mbps</td> <td>有线电视同轴电缆</td> <td>很长</td></tr>     
		<tr><td>光纤</td><td>40Gbps</td> <td>光缆</td> <td>很长</td></tr>     
		<tr bgcolor="#EAEAEA"><td>无线</td><td>10Mbps(3G)</td> <td>通信基站</td> <td>10km</td></tr>     
	</tbody>     
</table>     

#### 各个层次数据单元的名称纠正     
「报文」-- message -- 应用层     
「报文段」-- sagment -- 传输层      
「分组」-- packet -- 网络层    
「帧」-- frame -- 数据链路层     

#### 常用工具     
`Wireshark` -- 分组嗅探器     
`telnet` -- 远程登录工具（via TCP）     
`nmap` -- 端口扫描     

#### HTTP协议     
非持续连接的TCP，可并发连接     
无状态协议（通过cookie保留状态）     

#### FTP协议(File Transfer Protocol)     
两条TCP，20端口传数据，21端口传控制命令     
21端口保持连接（持续连接），整个会话期间`保留用户状态`     
20端口仅在需要时发起连接，非持续连接     

#### SMTP协议     
Simple Mail Transfer Protocol, 可参考RFC 5321     
『关于MIME』     
历史遗留问题，仅支持7为ASCII编码，即第1bit必须是0。     
流行解决方案--》`base64`，即用64个可打印字符编码二进制文件     
算法概要：     
64就是2的6次方嘛，于是每6bit的源文件，可以映射到一个「可打印字符」     
从源文件中取出24位，分成4份，每一份映射一个可打印字符     
于是，本来3个字节的文件(24bit)，被编码成了4个字节(4个可打印字符)     

#### UDP协议     
『相对于TCP，UDP的优势』？     
1. 对于数据发送的时刻控要求更精细（延时敏感）。因为TCP有拥塞控制。     
2. 没有三次握手的延时开销。     
3. 没有维持连接的开销。     
「问题」：由于UDP没有拥塞控制，而TCP有，所以在网络拥塞时，TCP会降低发送速度。产生UDP抑制TCP的情况。（所以迅雷下载时UDP？）     

#### TCP协议     
TCP要点：     
1. 把数据看成无结构的字节流，但是发送时，会把数据拆分、组装成报文段。     
2. 对数据按照`字节`编号     
3. 累积确认，确认是期望收到的下一个字节编号     

##### TCP是「回退N帧」还是「选择重传」？     
答：两者的结合。如果中间的报文段丢失，会先缓存后面的内容。但是TCP并没有单独对每个报文段进行确认，所以也不能算时选择重传。     

##### TCP的「快速重传」     
当连续收到三个冗余ack的时候，可以确认这个ack编号的报文段丢失，不必等到其超时，就直接重传它。     

##### **关于「SYN洪范」攻击**     
『产生原因』：     
TCP在三次握手时，服务器发送第二次握手（SYNACK）时就为连接分配资源，等待用户发来的第三次握手。如果这时客户端不再握手，这些资源需要会在1分多钟后由于超时被释放。于是在这1分多钟内，大量SYN请求可以耗尽服务器所有资源。     
『解决方案』：     
把资源分配调整至最后一次握手完成后，于是前两次握手不保存连接状态，判断如果接收到用于发来的第三次握手就为其分配连接资源。但是这样有个问题，如果黑客模拟第三次握手的报文段不是一样还是要分配资源给攻击者吗？解决方案是：在发送第二次握手时，给一个特殊的seq值，因为收到的第三次握手ack应该是这个seq加1嘛，所以只要鉴别这个ack是不是正确的就可以了。怎么做到这个ack不能伪造呢？答案是哈希，用客户端ip和端口哈希一个值，这个哈希算法保密。这样黑客就无法得知正确的ack数字了，想知道ack数字的话，只能老老实实建立前两次握手，等服务器把seq发给你。     

##### TCP连接的关闭     
四次握手，你关你的，我关我的，你懂得！     
「为什么要有`TIME_WAIT`」状态？     
`主动断开的一方`（一般是客户端），在收到对方的FIN请求后（第三次握手），会发出一个ACK（第四次握手）。对方收到这个ACK后，释放资源。但是担心这个ACK丢了，然后你自己关了，人家以为你没收到FIN，然后狂发，一直等你。。。为了解决这个问题，客户端发出FIN以后，再等待1或2分钟，如果期间收到重发的FIN，则说明ACK丢了，那就再发一个ACK。     

---     

#### 「路由器」和「交换机」再辨析     
交换机呢，只转发MAC帧，逻辑上相当于「同轴电缆」，但是与其相比，可以减少以太网的碰撞。     
路由器呢，会把MAC帧解开看下ip地址，所以能屏蔽广播帧。     
关于市售「路由器」，实际上是个`三层交换机`，并不维护路由转发表，反而是有NAT同能维护了NAT映射表。     

#### 再谈NAT     
啥是NAT？ Network Address Translation）     
为啥要有？因为ip地址不够用     
什么形式？在内网用保留ip自己玩，出去了，套一个公网ip。从外面看起来就像只有一台主机。     
多个主机用了同一个ip，怎么区分？     
维护`NAT转换表`，为每一个内网`SOCKET`(注意不是主机)，分配一个临时的公网端口号（端口号有16bit）。当NAT网关收到进来的数据时，就查这个表，把公网端口号的数据，转发给内网的SOCKET。     
「问题来了」，这个机制是，先出去，分配端口号，然后才能在NAT转换表上登记。如果不出去，外面是连不进来的。（网关表示很无奈，里面那么多人，我咋知道你要连谁？）     
「解决方案」，`端口映射`。强制要求NAT网关，把这个端口号收到的所有数据指定转发给某一台主机即可。（这样只能有一个人这样干。。。）     
「另一种方案」，找中继。先从里面连接到外面一台中继主机，然后通过该主机listen别人的连接请求。     


#### 网络安全四大问题     
1. **内容机密性**（确定不能被第三方读取）     
流行算法：`RSA`。公钥公开，私钥私藏。一方加密后可用另一方解密。「为什么要分公钥私钥呢？」其实也可以两个人用一样的钥匙，但是钥匙也是要传输的，你难以保证钥匙的安全。搞一个公钥，就算别人拿到也没问题，因为你就算拿到公钥也没法解开别人用公钥加密的内容。等等，那他岂不是可以解开我私钥加密的内容？是的，这个问题需要靠「端点鉴别」解决。     

2. **报文完整性**（确定未被修改）     
用哈希。如果报文被修改，哈希出来的数值就不一样了。哈希算法私密即可，也可以在公开的哈希算法上，增加一个私密的key。     
例子：「数字签名」     
逻辑前提，私钥是只有我自己有的，所以，私钥加密过的文件，相当于我签过名了。     
可以对于整个文件用私钥加密，但是这样代价比较高。流行的方法是，把文件的哈希值加密。因为哈希值和文件是一一对应的，对哈希值签名等同于对文件签名。     

3. **端点鉴别**（确认对方未被冒充）     
光光用口令是不够了，存在口令被监听的情况。加密后的口令也是不行的，黑客可以直接复制加密后的口令。那怎么办呢？方法是让加密后的口令复制无效。方法是：你要连接我时，我给你发一个随机数，然后你用你的私钥加密这个随机数传回给我，我解开是发现就是我给你的这个数，就说明你是真人。这样即使黑客截取报文，下次随机数就不一样了，无法连接。     
另：「证书认证」，有专门的机构，证明这个公钥属于谁谁谁。     

4. **运行安全性**     
防火墙。     

#### SSL是什么？     
SSL是：安全套接字层（Secure Socket Layer）。SSL使用位于应用层和传输层之间，调用传输层SOCKET，给应用层提供安全的数据传输。例子：`HTTPS`、`SSH`.     

简单过程：     
1. 建立TCP连接     
2. 客户发出SSL请求     
3. 服务器给客户发送一个认证过的公钥，确保这个公钥一定是服务器的     
4. 客户用这个公钥，去加密一个`自己临时生成`的「主密钥」，发给服务器，用于本次通信。     
5. 此时即使其他人监听到这个加密过得主密钥也没事，因为只有私钥能解密。     
6. 服务器收到这个「主密钥」后用私钥解密，然后它就得到了和客户端一样的「主密钥」     
7. 自此开始，他们使用`相同的`「主密钥」进行安全通信。     
所以，`前提`是服务器要有一个认证过得公钥。     




