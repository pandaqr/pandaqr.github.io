---     
layout: post     
title:  "读《现代操作系统》"     
date:   2015-09-9 15:26:00     
categories: basic theory     
---     

考研的时候操作系统是学得最好的一门课，看这本书主要是拾遗补缺。     

#### 操作系统的功能：     
1. 硬件抽象（文件）     
2. 资源管理     

#### 进程和线程若干细节     
1. 每个进程在自己的虚拟地址空间中，拥有独立的堆栈。     
2. fork是UNIX系统中唯一能创建新进程的system call。     
3. 创建一个进程的速度，比创建一个线程慢1-2个数量级     
4. 对于「`内核级线程`」系统内核空间中，保存了「进程表」（包含pcb）和「线程表」（包含每个线程的寄存器）。对于「`用户级线程`」，则有进程自己管理线程表。     
5. 「重要的事情再强调一遍」：进程是资源调度的单位，线程是CPU调度的单位。     
6. system call的时候，调度器没有执行，仍然是当前进程在工作。只是进入内核态以后，该进程有另外的堆栈及pc计数器（`内核上下文`），拥有高权限。这个内核上下文是用来应对内核态时遇到的时间片轮转以及阻塞后的恢复，同样存放在pcb中。     

#### Linux的进程内存地址空间细节     
1. 32位机器上，linux虚拟地址空间位4GB，1GB给操作系统，其他给进程。这1GB只有在内核态时可被访问。「注意」windows应该是2GB     
2. 内核的1GB，在`虚拟地址空间`中是`高地址`（顶部），然而映射到`物理内存`中是最`低地址`。     
3. 进程的3GB虚拟空间中，最底下是`代码段`，从0地址开始。接着往上是`已经初始化的全局变量`，操作系统并不区分这两者。再往上是`未初始化的全局变量`（历史上叫BSS，原因不明），可以`向上`动态增长，也就是传说中的`heap堆`。中间空白，然后到最顶上，贴着3GB的顶，是`stack栈`，每次调用函数，`向下`分配一块固定的大小。（所以，在函数定义时，栈大小必须是确定的。这是导致数组不能动态指定大小的原因。）     

#### 文件系统补充     
1. FAT表要读到内存里，太大的硬盘会让这个表很大占用内存     
2. inode统一放在磁盘的一片区域，然后有一个bit-map记录inode是否已用。（读入内存）     
3. Linux的文件系统叫ext2     

#### 日志文件系统（LFS）     
1. 为什么要日志？：磁盘操作分多步骤（写目录，写inode，写文件），中间如果遇到故障就导致文件丢失。     
2. 怎么办？：a)在做操作之前，在日志区域，写下将要做的操作。b)开始操作。c)操作完成后删除刚刚写的日志。     
3. 有什么用呢？：于是如果中途出问题，就会在日志区域留下日志，系统开机时，只要检查日志区域如果有东西，就把那个日志再完整执行一遍即可。     
4. 有什么overhead嘛？：有，所有的操作必须保证重复执行不会有副作用。（因为可能执行了几步断掉，然后重启后再执行一遍。）（这叫`幂等操作`）     

#### 安全问题     
1. 加密过程`‘盐’`的作用？：主要担心对于已知加密算法的`预计算`，黑客可以根据预计算的串与加密后的密码比对，从而得到密码。加盐可以让预计算失效。相当于个性化定制加密算法。     
2. `一次性口令`。「功能」：不怕网络流量嗅探，不怕服务器存储密码的文件被窃取。「步骤」：a)与服务器约定加密算法f，和加密次数n。b)首次登录时，用户给服务器的是`对原始密码用f加密n次的串`，服务器存储这个值。c)第二次登录时，给服务器发送`对原始密码用f加密的n-1次的串`，服务器只要把这个新串用f加密一次，与上一个密码比对一致即通过。d)当n被减到0时，重新来一次这样的设定。n的大小一般比较大。e)这样搞以后，就算黑客获取到本次的密码，但是无法计算出下一次的密码。「要求」：加密算法比较简单，应该算是一种简单的哈希，同时要求哈希完毕的产出长度与输入一致。这俩要求都是因为要迭代n次。另外的要求是不可逆。     

#### windows中的注册表     
实质是统一集中管理的配置文件集合，在开机时载入内存。注册表让`热插拔`成为可能。（书中并没有解释为什么，待科普）     

---     

### 附录：考研时期操作系统笔记精选     

---     

#### 进程管理     
进程是操作系统管理运行中程序的一种抽象，由PCB进程管理。process control block。PCB存放在系统「内核空间」中，主要内容包含：     
1) 资源清单（打开的文件等）     
2) 进程的控制信息（代码段在虚地址空间的地址、`页表`、根目录等）     
3) CPU上下文 （寄存器值、堆栈指针）     
4) 内核态CPU上下文     

#### 进程调度的几个思想     
a）优先级：优先处理响应时间要求较短的任务。（多级队列）     
b）抢占：高优先级任务到来时，暂停正在处理的低优先级任务，先处理高的。     
c）时间片轮转：各个进程轮流运行一段时间，保证响应时间有`上限`。     
d）反馈：时间片如果不够用，则说明你`目前`是CPU繁忙，那下次就给你更长的时间片，更低的优先级。反之，如果用不完你就自己block了，则说明你目前是IO繁忙，下次给你短时间片，更高优先级。     

「为什么一般优先处理IO繁忙进程？」：为了让IO和CPU资源有效并发工作。     

#### 进程间通信     
1. 同步互斥（信号量）     
2. 管道     
3. 共享内存     
4. 进程间消息     

「什么是`临界区`」：访问共享资源的一段`代码`。     
「PV操作解决竟态问题的关键在哪里？」：1.原语不可被打断（捆绑了加锁和访问计数器的操作）。2.等待时自动阻塞，释放CPU。     


---     

#### 内存管理     
_     
##### 内存分页     
「目的」：解决内存分配的`碎片`问题。分页后碎片平均为页面大小的50%。     
「为啥页面的大小一般是2的幂次？」：方便通过内存地址计算页面号。     
「为啥要有页表？」：实现虚地址和物理地址的映射。     
「为啥要有快表TLB？」：`页表存放在内存里`（PCB中），所以每次访问一个内存地址，实际上要读两次内存，这是无法忍受的。TLB是一个硬件，相当于页表的Cache。     
「为啥要有多级页表？」：虚地址空间好大，于是页表好大。然而那么多的地址空间，对于单个进程来说，大多数是空的。多级页表可以只把用到的页表加载到PCB中，控制页表的大小。当然也会增加页表的访问次数。另外，多级页表中，项目的数量应当也是2的幂次，方便根据地址高位查找。     

##### 虚拟内存     
「理论基础」：程序的局部性原理。     
「什么是Belady现象？」：分配给进程的物理页面增加时，它的缺页率反而提高的现象。     
「影响缺页率的因素」：1）页面替换算法。2）配给的页面数。3）编程方式。     
「页面分配策略」：a）固定分配：配给进程的物理页面数量恒定。b）可变分配：缺页率较低的进程可以让出物理页面给需要的进程。     

##### 内存分段     
「目的」：程序实际上是有结构的，如代码段、堆栈等。按照进程的结构区分内存区块，有利于动态加载以及共享。     
「段页式内存分配」：先分段，段内再分页。先查段表，再查页表。     


---     

#### 文件系统     
_     
##### 存放方式     
a）链表存放---FAT表，一种`静态链表`。知道首块地址就能依次查找到最后。     
b）索引存放---iNode节点。所有块的地址都写在这个node里。     
「为何要有二级索引？」iNode大小有限（磁盘区块大小），于是存储的索引项目有限，需要用二级索引扩容。     

##### 空闲区块管理     
a）bit-map     
b）把所有空闲块号组成一个链表     

##### 二进制打开文件和ASCII打开文件的区别？     
ASCII打开时会去辨认`换行符`（Win是`\r\n`，Linux是`\n`，Mac是`\r`），可以`按行读取`。二进制打开则只能按字节读取，速度比较快。     



