---     
layout: post     
title:  "小规模C++语法笔记"     
date:   2015-02-13 22:00:00     
categories: 读书笔记     
---     

之前虽然有系统学过C++，但还是低估了`Primer`的事无巨细。在加上C++11的诸多变化，两三天根本看不完，还是不花太多时间复习语法了，先写起来吧~这里把这三天回顾的要点记录下来。     


#### 小Tips     
1. 无符号类型和有符号类型计算时，都化成无符号类型。所以切勿混用。     
2. 字符串字面值相邻，且中间仅有`空白字符`时，被编译成一个整体字符串常量     
3. 局部变量与全局变量重名时，在其生存期内覆盖全局变量，出了生存期消亡，全局变量在此期间不受影响。     
4. 常量（字面值）在编译期，全部替换成对应的值。     
   

#### 关于`=`符号     
1. 注意区分赋值和初始化，在变量定义时用`=`号为初始化     
2. 其他为赋值。赋值时，如果两者类型不同，先进行`隐式类型转化`。     

#### 定义和申明     
申明：用于给编译器产生符号表，可以多次申明     
定义 = 申明 + 申请内存空间 （不一定立刻分配）     

#### 再看`左值`和`右值`     
左值：的是这个「变量」所占的`内存区域`     
右值：这个「变量」所代表的`值`     
[注]即使不能被赋值，也可以是左值哦。如const对象。     

#### C++中的自增符号     
与C中略有不同：(C中两个都是右值)     
`++i`是`左值`，在表达式中参与计算的时i`本身`     
`i++`是`右值`，参与计算的是i在增加前的`副本`     

---     

#### 关于别名     
除了`typedef`，c++11中增加了新的`using new_name = old_name`方式，却别不明。     
[注]对于别名的指针，在理解其类型时，请不要把别名替换成本来的样子以后再去解读，应该把别名看成一个整体类型。     
例如：     
{% highlight cpp %}      
typedef char *pstring;     
const pstring var;   // var是指向char的常量指针（顶层const）     
//如果先做名称替换：const char * var;     
//则会把var误读成指向const char的变量指针（底层const）     
{% endhighlight %}      

---     

#### NULL和nullptr     
nullptr是c++的`关键字`，有自己的数据类型，NULL是宏定义常量     
##### 为何需要nullptr？请看例子：     
{% highlight cpp %}      
void f(void*){}     
void f(int){}     

int main(){     
    f(NULL); // which function will be called?     
}     
{% endhighlight %}        
上面代码编译器表错，因为无法判断该调用哪个函数。有了nullptr后问题解决。     

---     

#### 顶层const和底层const     
主要用于描述指针或者引用。     
顶层const--`top-level const`--指针本身是常量     
底层const--`low-level const`--指针所指向的对象是const的     
[注]    
1. 顶层const经常在赋值或传参后丢失，而底层const是不允许丢失的。    
2. 普通对象的const都是顶层const     

---     

#### auto和decltype     
用途：自动类型推断（实际应用？）     
谁来推断：编译器    
##### 「auto」:      
定义变量时，由定义时赋给它的`初始值`推断变量的类型。     
[例]`auto i = var1 + var2`     
[注]忽略顶层const，保留底层const。如需保留顶层const，请`const auto`     

##### 「decltype」:      
auto在推断类型时，必须给他赋初始值。decltype则仅仅是得到表达式的数据类型。（不计算，也不根据表达式的值来推断）     
[例]`decltype(func()) i = 1` （比如func的返回类型为int）（注意不计算func）     
规则：     
1. 括号内是`变量`。则直接拷贝变量的类型（原样拷贝，不像auto忽略顶层const）     
2. 括号内是`表达式`，则要看表达式结果是一个`左值`和`右值`。     
    - 如果是左值：返回这个值的`引用`类型。     
    - 如果是右值：则直接拷贝这个值的类型。     
> [注]     
1. 不知道为啥要把左值搞成引用，有待研究     
2. 对于带括号的单个变量，编译器会解释为表达式，所以，`decltype((i))`这种两层括号的变量，一定会返回一个引用的i的类型。请小心！     
3. 为啥要有「类型推断」？好处在哪里？请研究！     

---     

#### 范围for语句     
对于C++11新增的：`for(auto item : contaner)`     
实际上处理为：     
{% highlight cpp %}      
for(auto it = contaner.begin(); it != contaner.end(); ++it){     
    auto item = *it;     
    //以下是原来的循环体     
}     
{% endhighlight %}      
所以，实质上还是依赖于`迭代器`-->迭代器可能失效时不能用这种for！     

---     

#### 再看函数
1. 可变参数
2. 默认参数


---

#### 显示类型转化     
与C语言单一的强制转化不同，C++的类型转化细分为四种，分别完成旧式C强转的功能：     
##### `static_cast`     
用途：普通的类型转化，可以调用class的构造函数    
[注]    
1. 不可转化底层的const。    
2. 比较安全，转化时会翻译二进制。    

##### `dynamic_cast`     
用途：把「基类」指针`安全地`转化为「派生类」指针或引用。

##### `const_cast`    
用途：专门用于转化「底层const」。     
一般情况下底层const是不允许丢失的，如果强制把底层const去掉，修改指向的常量的话，会发生不可预知的错误。（因为人家常量在编译的时候已经变成数字了。。。）     
那这东西能用在哪里呢？     
主要用在函数调用时的参数适配，先把它转成底层const，调用函数，然后再去掉。。。这样可以很方便地用一个写好的const版本函数，重载出一个非const版本的函数（强转，然后调用const版本）。     

##### `reinterpret_cast`     
用途：正宗的强制转化。机器级的重新解释二进制。例如把int*强转char*

---     

#### 调试帮助     
_     
##### assert断言     
`assert`不是函数，是「宏」。定义在`cassert`头文件中。     
[重要]assert可在编译时取消：     
在头文件中`#define NDEBUG`即可让assert失效。     
也可在编译时加入选项：`g++ -D NDEBUG xx.cpp`     

##### 预定义宏     
除了C语言中的__LINE__外，增加一个有用的`__func__`（注意小写！）     



---     

#### 「直接初始化」和「拷贝初始化」     
举例说明：     
{% highlight cpp %}      
string ss = "这是拷贝初始化"     
string ss("这是直接初始化")     
string ss(10, 'a')  //这也是直接初始化     
{% endhighlight %}      
区别：     
直接初始化--直接调用相应类型的构造函数     
拷贝初始化--先把`=`号右边的内容用`构造函数`隐式转化成该类型，再调用`拷贝构造函数`     
> [注]函数传参的时候，是用「实参」拷贝初始化「形参」的。     

---     

#### 重载与函数匹配     
_     
##### 为什么C++能重载而C不能？     
C在编译时的符号表仅有函数名，而C++在函数名的基础上，加上了参数。所以认为，名称相同、参数不同的函数是不同的。     
##### 重载规则     
1. 参数可以重载，返回值不能重载     
2. 参数不可以重载顶层const。 例子：     
{% highlight cpp %}      
void func(const int i);   //i在func作用域内为常量，只读     
void func(int i);         //非法，     
                          //因为对于int类型的实参，编译器不知道该调用谁     
//底层const重载是合法的。     
{% endhighlight %}      

##### 函数匹配     
调用重载的函数时，具体调用哪一个，规则如下：     
1. 没有最佳匹配时，允许参数的隐式转化，但是越少越好     
2. 如果两个都有转化，必须有一个`完爆`另一个（至少有一项比你强，没有任何一项比你差）     
{% highlight cpp %}      
void func(int, double, int){}       //1     
void func(double, int, int){}       //2     
void func(double, double, int){}    //3     

int main(){     
    func(3.14, 3.14, 3.14);         //对于1，第一和第三个参数转化     
                                    //对于2，第二和第三个参数转化     
                                    //对于3，仅第三个转化。所以3完爆1和2，调用3     
                                    //如果没有3，则报错，1和2谁也不能完爆谁     
}     
{% endhighlight %}      

---

#### 类
内容较多，只讲重点

##### 类作用域
对于private的成员，仅本类内部和friend能访问。

##### `this`指针
在「对象」调用成员函数时，`隐式传递`指向「该对象地址」的this指针。
[注]所以，成员函数的参数列表，其实默认多一个指针。

##### const成员函数
因为this指针是隐式传递的，那么对于const对象，this指针的底层const谁来保护呢？答案是const成员函数，写在参数后面的const，实际上是表示传递的this指针是底层const的，即在这个函数中，不能对该对象进行修改。
[注]但是可以修改mutable的成员。

##### 构造函数
1. 如果你不管，会默认生成一个无参的版本。
2. 如果你写了，不管有没有参数，编译器就不会帮你默认生成了
3. 此时如果还想要默认的，请`Class_init()=default`（C++11新功能）
[注]不能为const，不能private（想想就知道不行）

##### 构造函数的初始值列表
初始化时，仅按照类成员的书写顺序，初始化列表的顺序不管的。所以，最好把初始化列表的顺序写得和类成员顺序一致。

##### 禁止调用构造函数去隐式类型转换
如果不想被系统自动调用这个构造函数，请`explicit`

