---     
layout: post     
title:  "C++的本质"     
date:   2015-12-22 00:46     
categories: cpp     
---     

此笔记为C++之父2014年的讲座『the essence of C++』。讲了cpp的本质以及近年来cpp11及14的改进。     

#### CPP的设计用途     
- 系统编程     
- 嵌入式系统     
- 资源限制的系统     

#### CPP的抽象层级     
「轻量级」抽象的编程语言，希望用最小的代价实现抽象。     

---     

#### 关于「资源管理」     
任何资源（包括内存、文件、socket、锁、线程等）都应该使用一个`handle`来管理。     
##### 什么是handle？     
>A resource should be owned by a “handle”     
>A “handle” should present a well-defined and useful abstraction     
>E.g. a vector, string, file, thread   

handle就是一个代理，由handle去持有资源、管理资源。外界持有handle就可以了。     
这样做主要是为了贯彻`RAII`的资源管理方式（Resource Acquisition Is Initialization），即「资源的handle在`初始化`时持有这个资源，在`析构`时释放资源」     
##### 为啥需要handle？     
直接持有资源会容易在特殊情况下难以「释放」。例如：     
1.中途抛出异常     
2.中途退出函数     
3.多线程间共享资源     
##### CPP标准库中设计好的handle     
- STL中的vector、list、thread等     
- `shared_ptr`(引用计数)、`unique_ptr`(不带引用计数)     
- ....    

##### 那什么时候用`裸的指针`？     
仅在handle的内部。     
「注」裸的数组也是不推荐使用的，容易被攻击，且没有越界检查。     

---     

#### 一个困扰的问题：如何从函数中传出大量数据？     
对于「工厂函数」或者其他要创造出新变量的函数，都需要在函数结束后返回一大堆`新的`数据。处理方式主要有以下几种：     
- 返回函数的局部变量（错误方法，堆内存在函数执行后被销毁）     
- 返回new出来地址的指针（有问题，谁有责任去释放这块内存？）     
- 返回new出来地址的引用（问题更大，外面的哥们儿怎么释放它？）     
- 预先准备好一个变量，作为「传出参数」（很丑，UNIX中常用）     
在C++11，解决了这个问题。解决方式是：`移动构造函数`(move constructor)     

##### 啥是「移动」？     
从设计初衷的角度看，首先避免`拷贝一份然后把原来的销毁`这种消耗资源的方式。其次对于传递指针地址的方式，主要问题也是出在「资源管理」。所以对于这样的资源如果用handle，只需要把handle持有的资源转移过去。这样copy的只是handle，代价小。     
##### 所以移动的「前提」你要是一个handle。     

---     

#### 关于垃圾回收     
垃圾回收的问题主要如下：     
1. 不可预测     
2. 性能开销     
3. 只管理内存，不管理其他资源（锁、线程等）     
「注」：C++11开始也支持垃圾回收了。STL     

---     

#### 关于泛型     
- 是一种廉价的（non-overhead）元编程     
- CPP14给泛型增加了类似于`协议`或者`接口`的功能     
- 改善了泛型的错误提示     

---

最后，附上链接：https://www.youtube.com/watch?v=86xWVb4XIyE

