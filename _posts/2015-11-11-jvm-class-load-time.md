---
title: 深入理解JVM—类加载的时机
layout: post
---

<p>最近在读《深入理解Java虚拟机：JVM高级特性与最佳实践》这本书，对于深入理解JVM的基础技术概念大有帮助，现对「类加载时机」这块逻辑处理过程进行一个简单的回顾和总结。</p>

<p>众所周知，JVM在字节码上运行，字节码从何而来，从高级源码编译过来，当年在制定Java虚拟机规范时并没有强制规定JVM只能运行由Java源代码编译过来的字节码，不管何种高级开发语言，只要编译后的字节码符合JVM的规范，理论上都能在JVM上运行，好了，扯远了。Java程序从加载到虚拟机内存中开始，到从内存中移出大致需要经历以下过程，如下图所示：</p>
<span class=""><img src="/assets/images/2015/11/jvm-class-load-time.png" alt="类加载的时机"></span>

<p>我们从逻辑上把Java程序执行的完整链条切割成各个阶段，后一阶段的顺利执行取决于上一阶段的执行结果，前后依赖。下面对各个阶段所执行的操作作一简单介绍：</p>

<p>
加载：我们在这里说的加载指的是类的加载，大致需要完成以下几件事情：
1）根据类的全路径名称获取描述此类的二进制字节流。这个动作一般通过「类加载器」来实现，「类加载器」是一块在Java虚拟机外部实现的动作代码，从Java虚拟机的角度出发，存在两种不同的类加载器：启动类加载器（由C++实现，是JVM的一部分）和其他类加载器，启动类加载器负责把<JAVA_HOME>\lib目录中的类库加载到虚拟机内存中；其他类加载器中的扩展类加载器负责加载<JAVA_HOME>\lib\ext目录中的类库；应用程序类加载器则负载加载用户类路径上指定的类库。
2）将这个字节流所代表的静态存储结构（比如类变量）转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的Java对象，通过该对象来访问该类的各种数据。
</p>

<p>
验证：确保上一步加载进虚拟机的字节流不包含危害虚拟机自身安全的信息，主要进行以下几个验证操作：
1）文件格式验证：验证字节流是否符合Class文件格式的规范；文件格式验证基于二进制字节流进行，通过该验证之后，字节流才会进入内存的方法区中进行存储，所以后面的验证操作都基于方法区中的存储结构进行，不会再直接操作字节流；
2）元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息；
3）字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
4）符号引用验证：对类自身以外的信息进行匹配性校验，比如通过字符串描述的全路径名称是否能找到对应的类。
</p>

<p>
准备：为类变量在方法区中分配内存空间，并设置初始值，需要注意几个关键的地方：
1）仅仅只为类变量（类中以static修饰的变量）分配内存空间，并设置初始值；
2）准备阶段为变量设置初始值一般指的是变量对应类型的零值，比如public static int xyz = 123，准备阶段过后变量xyz的初始值为零，123赋值给xyz的操作需要等到初始化阶段才真正执行，但是也有一个例外情况：如果变量xyz具有ConstantValue常量属性，public static final int xyz = 123，那么xyz在准备阶段就会被初始化成值123。各变量对应的零值如下图所示：
</p>

<p>解析：主要完成把常量池内的符号引用替换为直接引用</p>

<p>
初始化：真正开始执行类中定义的Java程序代码（其实是字节码）
初始化阶段主要执行类构造器<clinit>()方法，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，另外需要注意以下几个比较重要的地方：
1）<clinit>()方法与类的构造函数不同，前者不需要显式的调用父类的<clinit>()方法，Java虚拟机保证会在调用子类的<clinit>()方法之前先执行父类的<clinit>()方法，也就意味着父类中定义的静态语句块先于子类的变量赋值操作。
</p>

<p>解析这一阶段所需要完成的工作相对来说是比较复杂的，可以另外再进行说明。</p>