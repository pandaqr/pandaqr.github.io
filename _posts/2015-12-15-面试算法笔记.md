---     
layout: post     
title:  "面试算法笔记"     
date:   2015-12-15 10:45     
categories: theory     
---     

记录一些经典的算法问题，希望举一反三。     

#### 2-sum问题     
_     
##### 问题简述：     
给定一个值，在一组数字中，找出两个数，加起来的和等于这个给定的值。     

##### 常规思路：     
挨个取出元素，再与其他值挨个相加，判断是否等于需要的值。     
「复杂度」：O(n2)     

##### 好思路-hash优化     
取出元素后，并不需要与所有的其他值相加，只需要查找是否存在等于`「目标值-当前值」`的元素。鉴于「线性查找」的复杂度较大，把元素存入hash表后再进行查找即可做到常数级时间复杂度。故总体的复杂度为O(n)。     

总结：对于算法中某个步骤涉及到「查找」的，可用hash`空间换时间`。     

##### 好思路-先排序再找     
先对所有元素进行排序，然后用双指针一头一尾。加起来偏大就移尾巴，加起来偏小就移头。迭代多次后可以找到需要的两个数。     
「复杂度」：O(nlogn) + O(n) = O(nlogn)     


「我的疑问」：这样子，不会跑过头吗？那会不会尾巴尾巴一直加加加过头了？     
「答」：不会。因为如果一直偏小，尾巴指针到达较小的那个数时，这时加起来的「和」一定就大于目标了，所以这时一定会是头部指针移动，尾巴指针停在那个位置。除非不存在这两个数，那么两个指针会相遇。     

总结：对数据进行预处理，在计算复杂度时是与后续步骤`「相加」`的，那就只会取一个较大的值。相对于复杂的算法（相乘）会比较划算。     


----     

#### KMP简要思路     
在字符串匹配中，KMP解决暴力法中「指针回溯」的问题（复杂度O(M*N)），做到线性复杂度。但是理解起来有点困难，核心点是以下两个：     
1. 对于`各不相同`的pattern串，前一次比较时与目标串匹配的这些字符，`一定不可能和pattern「首字符」相同`，因为「首字符」不等于「后面的字符」，而这些字符与pattern串「后面的字符」已经匹配相同，所以这些都不用比较，首字符就不匹配了。     
2. 对于`后面有与首字符相同`的情况，上面的假设就不成立了。既然pattern串前后有相同，那就要从首次相同的位置再次进行比较。所以我们在KMP算法中的next数组是`这个位置往前的「最长首尾相同字串」`。最后，因为既然已经知道这几个字串是相同的，那也不用比较了，直接从下一个位置开始就好了。     

「另外」next数组的意思是什么？     
直观的理解，next数组的每个元素，表示当匹配到这个元素不相等时，与目标串位置`下一个`参加比较的pattern串的「下标」。（未验证）     

##### KMP的最坏情况
pattern串中大量相等时（最差是全部相等），next数组值会越来越大。导致效率降低（复杂度上届为O(2N)）。    
「解决」改进的KMP，就是计算next数组时，如果发现next到的元素与当前元素相同，那就肯定不会匹配成功，那就跳过它，直接比较next元素的next就好了。在数组中，就表现为：    
`若P[next[i]]==P[i];`    
=>     
`则next[i]=next[next[i]]`        


「注意」KMP远没有那么简单，书中还设计到「自动机理论」，实际算法中求next数组算法也非常精妙。有待补充深入。     


---     



